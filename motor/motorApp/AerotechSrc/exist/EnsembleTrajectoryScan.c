/* C code for program EnsembleTrajectoryScan, generated by snc from EnsembleTrajectoryScan.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 24 "EnsembleTrajectoryScan.st"
#include <stdlib.h>
# line 25 "EnsembleTrajectoryScan.st"
#include <string.h>
# line 26 "EnsembleTrajectoryScan.st"
#include <ctype.h>
# line 27 "EnsembleTrajectoryScan.st"
#include <stdio.h>
# line 28 "EnsembleTrajectoryScan.st"
#include <math.h>
# line 29 "EnsembleTrajectoryScan.st"
#include <epicsString.h>
# line 30 "EnsembleTrajectoryScan.st"
#include <epicsStdio.h>
# line 31 "EnsembleTrajectoryScan.st"
#include <asynOctetSyncIO.h>
# line 159 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID pulsePositionsMon = 1;
# line 345 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID buildMon = 2;
# line 346 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID executeMon = 3;
# line 347 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID execStateMon = 4;
# line 348 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID abortMon = 5;
# line 349 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID readbackMon = 6;
# line 350 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID nelementsMon = 7;
# line 351 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
static const EF_ID motorMDVSMon = 8;
# line 111 "EnsembleTrajectoryScan.st"
epicsTimeStamp startTime;
# line 112 "EnsembleTrajectoryScan.st"
epicsTimeStamp currTime;
# line 113 "EnsembleTrajectoryScan.st"
epicsTimeStamp lastPollTime;
# line 115 "EnsembleTrajectoryScan.st"
epicsTimeStamp pvtTime;
# line 116 "EnsembleTrajectoryScan.st"
epicsTimeStamp lastPvtTime;
# line 119 "EnsembleTrajectoryScan.st"
static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command);
# line 120 "EnsembleTrajectoryScan.st"
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply);
# line 121 "EnsembleTrajectoryScan.st"
static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos);
# line 122 "EnsembleTrajectoryScan.st"
static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask);
# line 123 "EnsembleTrajectoryScan.st"
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar);
# line 124 "EnsembleTrajectoryScan.st"
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar);
# line 125 "EnsembleTrajectoryScan.st"
static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *timeTrajectory,
# line 126 "EnsembleTrajectoryScan.st"
double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, int npulses, double motorOffset,
# line 127 "EnsembleTrajectoryScan.st"
double motorResolution, double *velocity);
# line 128 "EnsembleTrajectoryScan.st"
static int loadTrajectory(SS_ID ssId, struct UserVar *pVar);
# line 129 "EnsembleTrajectoryScan.st"
static int userToRaw(double user, double off, int dir, double res);
# line 130 "EnsembleTrajectoryScan.st"
static double rawToUser(int raw, double off, int dir, double res);
# line 131 "EnsembleTrajectoryScan.st"
static int sendReceiveCommand(SS_ID ssId, struct UserVar *pVar, char *cmd, char *callerReply, int checkProgram);
# line 132 "EnsembleTrajectoryScan.st"
static double trajEval(SS_ID ssId, struct UserVar *pVar, double *motorReadbacks, int scopeDataIntervalMS, int nScopeDataPoints,
# line 133 "EnsembleTrajectoryScan.st"
double *motorTrajectory, double *realTimeTrajectory, int npoints, double *motorError);
# line 134 "EnsembleTrajectoryScan.st"
int writeDoubleAndCheck(SS_ID ssId, struct UserVar *pVar, int n, double d);
# line 135 "EnsembleTrajectoryScan.st"
int writeIntAndCheck(SS_ID ssId, struct UserVar *pVar, int n, int ival);
# line 170 "EnsembleTrajectoryScan.st"
int encoder_runs_backwards=0;

/* Variable declarations */
struct seqg_vars {
# line 42 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int debugLevel;
# line 44 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int numAxes;
# line 46 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int nelements;
# line 48 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int npulses;
# line 50 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int startPulses;
# line 52 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int endPulses;
# line 54 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int nactual;
# line 55 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int moveMode;
# line 57 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double time;
# line 59 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double timeScale;
# line 61 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int timeMode;
# line 63 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double accel;
# line 65 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int build;
# line 67 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int buildState;
# line 68 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int buildStatus;
# line 69 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	string buildMessage;
# line 70 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int simMode;
# line 72 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int execute;
# line 74 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int execState;
# line 76 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int execStatus;
# line 77 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	string execMessage;
# line 78 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int abort;
# line 80 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int readback;
# line 82 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int readState;
# line 83 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int readStatus;
# line 84 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	string readMessage;
# line 85 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double timeTrajectory[1000];
# line 88 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	string trajectoryFile;
# line 94 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double elapsedTime;
# line 97 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double realTimeTrajectory[1000];
# line 101 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorMres[8];
# line 106 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int epicsMotorCard[8];
# line 111 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorHLM[8];
# line 114 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorLLM[8];
# line 118 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorStart[8];
# line 129 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int pulseDir;
# line 133 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double pulseLenUS;
# line 137 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int pulseSrc;
# line 149 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double pulsePositions[8000];
# line 156 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double newPulsePositions;
# line 162 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int numPulsePositions;
# line 169 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int pulseMode;
# line 175 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int moveAxis[8];
# line 187 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorTrajectory[8][1000];
# line 199 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorReadbacks[8][8000];
# line 210 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorError[8][8000];
# line 221 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorCurrent[8];
# line 232 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorMDVS[8];
# line 244 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorMDVA[8];
# line 255 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int motorMDVE[8];
# line 266 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorMVA[8];
# line 277 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int motorMVE[8];
# line 288 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double motorMAA[8];
# line 299 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int motorMAE[8];
# line 312 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorPos[8];
# line 316 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	int epicsMotorDir[8];
# line 320 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorOff[8];
# line 324 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorDone[8];
# line 328 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorVELO[8];
# line 332 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorVMAX[8];
# line 336 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorVMIN[8];
# line 340 "C:\\Users\\ktn98257\\source\\repos\\epics.dotnet\\motor\\motorApp\\AerotechSrc\\EnsembleTrajectoryScan.h"
	double epicsMotorACCL[8];
# line 75 "EnsembleTrajectoryScan.st"
	char stringOut[100];
# line 76 "EnsembleTrajectoryScan.st"
	char stringIn[100];
# line 77 "EnsembleTrajectoryScan.st"
	char stringLast[100];
# line 78 "EnsembleTrajectoryScan.st"
	char abortCommand[100];
# line 79 "EnsembleTrajectoryScan.st"
	char *asynPort;
# line 80 "EnsembleTrajectoryScan.st"
	char *pasynUser;
# line 81 "EnsembleTrajectoryScan.st"
	int status;
# line 82 "EnsembleTrajectoryScan.st"
	int i;
# line 83 "EnsembleTrajectoryScan.st"
	int j;
# line 84 "EnsembleTrajectoryScan.st"
	int k;
# line 85 "EnsembleTrajectoryScan.st"
	int n;
# line 86 "EnsembleTrajectoryScan.st"
	int anyMoving;
# line 87 "EnsembleTrajectoryScan.st"
	int npoints;
# line 88 "EnsembleTrajectoryScan.st"
	double dtime;
# line 89 "EnsembleTrajectoryScan.st"
	double dpos;
# line 90 "EnsembleTrajectoryScan.st"
	double posActual;
# line 91 "EnsembleTrajectoryScan.st"
	double expectedTime;
# line 92 "EnsembleTrajectoryScan.st"
	double initialPos[8];
# line 93 "EnsembleTrajectoryScan.st"
	char macroBuf[100];
# line 94 "EnsembleTrajectoryScan.st"
	char motorName[100];
# line 95 "EnsembleTrajectoryScan.st"
	int initStatus;
# line 96 "EnsembleTrajectoryScan.st"
	int limitViolation;
# line 97 "EnsembleTrajectoryScan.st"
	int loadingTrajectory;
# line 101 "EnsembleTrajectoryScan.st"
	int motorCurrentIndex[8];
# line 102 "EnsembleTrajectoryScan.st"
	int epicsMotorDoneIndex[8];
# line 103 "EnsembleTrajectoryScan.st"
	int elapsedTimeIndex;
# line 109 "EnsembleTrajectoryScan.st"
	int abortState;
# line 136 "EnsembleTrajectoryScan.st"
	double position[8][1000];
# line 137 "EnsembleTrajectoryScan.st"
	double velocity[8][1000];
# line 139 "EnsembleTrajectoryScan.st"
	double motorCurr[8];
# line 140 "EnsembleTrajectoryScan.st"
	double motorPosOffset[8];
# line 143 "EnsembleTrajectoryScan.st"
	int movingMask;
# line 144 "EnsembleTrajectoryScan.st"
	int numGlobalDoubles;
# line 145 "EnsembleTrajectoryScan.st"
	int numGlobalIntegers;
# line 148 "EnsembleTrajectoryScan.st"
	double vmax;
# line 149 "EnsembleTrajectoryScan.st"
	double amax;
# line 150 "EnsembleTrajectoryScan.st"
	double d;
# line 150 "EnsembleTrajectoryScan.st"
	double dlast;
# line 156 "EnsembleTrajectoryScan.st"
	int nScopeDataPoints;
# line 157 "EnsembleTrajectoryScan.st"
	int scopeDataIntervalMS;
# line 172 "EnsembleTrajectoryScan.st"
	int pulsePositionsLoaded;
# line 173 "EnsembleTrajectoryScan.st"
	int numPulsePositionsLoaded;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "init" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 180 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 180 "EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:init: entry\n");
# line 181 "EnsembleTrajectoryScan.st"
			seqg_var->initStatus = 0;
# line 183 "EnsembleTrajectoryScan.st"
			if (seqg_var->numAxes > 8)
# line 183 "EnsembleTrajectoryScan.st"
				seqg_var->numAxes = 8;
# line 184 "EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numAxes; seqg_var->i++)
			{
# line 185 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->macroBuf, "M%d", seqg_var->i + 1);
# line 187 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VAL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 188 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 189 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->i));
# line 191 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DIR", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 192 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 181/*epicsMotorDir*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 193 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 181/*epicsMotorDir*/ + (CH_ID)(seqg_var->i));
# line 195 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.OFF", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 196 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 189/*epicsMotorOff*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 197 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 189/*epicsMotorOff*/ + (CH_ID)(seqg_var->i));
# line 199 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.DMOV", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 200 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 201 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->i));
# line 203 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.MRES", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 204 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 30/*epicsMotorMres*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 205 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 30/*epicsMotorMres*/ + (CH_ID)(seqg_var->i));
# line 207 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.CARD", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 208 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 38/*epicsMotorCard*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 209 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 38/*epicsMotorCard*/ + (CH_ID)(seqg_var->i));
# line 211 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.HLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 212 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 46/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 213 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 46/*epicsMotorHLM*/ + (CH_ID)(seqg_var->i));
# line 215 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.LLM", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 216 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 54/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 217 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 54/*epicsMotorLLM*/ + (CH_ID)(seqg_var->i));
# line 219 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VELO", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 220 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 205/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 221 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 205/*epicsMotorVELO*/ + (CH_ID)(seqg_var->i));
# line 223 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VMAX", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 224 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 213/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 225 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 213/*epicsMotorVMAX*/ + (CH_ID)(seqg_var->i));
# line 227 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.VBAS", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 228 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 221/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 229 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 221/*epicsMotorVMIN*/ + (CH_ID)(seqg_var->i));
# line 231 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->motorName, "%s%s.ACCL", seq_macValueGet(seqg_env, "P"), seq_macValueGet(seqg_env, seqg_var->macroBuf));
# line 232 "EnsembleTrajectoryScan.st"
				seq_pvAssign(seqg_env, 229/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i), seqg_var->motorName);
# line 233 "EnsembleTrajectoryScan.st"
				seq_pvMonitor(seqg_env, 229/*epicsMotorACCL*/ + (CH_ID)(seqg_var->i));
			}
# line 236 "EnsembleTrajectoryScan.st"
			seqg_var->asynPort = seq_macValueGet(seqg_env, "PORT");
			pVar->status = pasynOctetSyncIO->connect(pVar->asynPort, 0, (asynUser **)&pVar->pasynUser, NULL);
# line 238 "EnsembleTrajectoryScan.st"
			if (seqg_var->status != 0)
			{
# line 239 "EnsembleTrajectoryScan.st"
				printf("trajectoryScan error in pasynOctetSyncIO->connect\n");
# line 240 "EnsembleTrajectoryScan.st"
				printf("   status=%d, port=%s\n", seqg_var->status, seqg_var->asynPort);
			}
# line 242 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 243 "EnsembleTrajectoryScan.st"
				seqg_var->motorCurrentIndex[seqg_var->j] = seq_pvIndex(seqg_env, 109/*motorCurrent*/ + (CH_ID)(seqg_var->j));
# line 244 "EnsembleTrajectoryScan.st"
				seqg_var->epicsMotorDoneIndex[seqg_var->j] = seq_pvIndex(seqg_env, 197/*epicsMotorDone*/ + (CH_ID)(seqg_var->j));
# line 245 "EnsembleTrajectoryScan.st"
				seqg_var->motorPosOffset[seqg_var->j] = 0.;
			}
# line 247 "EnsembleTrajectoryScan.st"
			seqg_var->elapsedTimeIndex = seq_pvIndex(seqg_env, 28/*elapsedTime*/);
# line 248 "EnsembleTrajectoryScan.st"
			seqg_var->abortState = 0;
# line 251 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, buildMon);
# line 252 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, executeMon);
# line 253 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, abortMon);
# line 254 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, readbackMon);
# line 255 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, nelementsMon);
# line 256 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, motorMDVSMon);
# line 261 "EnsembleTrajectoryScan.st"
			seq_efClear(seqg_env, pulsePositionsMon);
# line 262 "EnsembleTrajectoryScan.st"
			seq_pvGetTmo(seqg_env, 73/*pulsePositions*/, DEFAULT, DEFAULT_TIMEOUT);
# line 263 "EnsembleTrajectoryScan.st"
			seqg_var->pulsePositionsLoaded = 0;
# line 264 "EnsembleTrajectoryScan.st"
			seqg_var->numPulsePositionsLoaded = 0;
# line 266 "EnsembleTrajectoryScan.st"
			if (seqg_var->initStatus == 0)
# line 266 "EnsembleTrajectoryScan.st"
				seqg_var->initStatus = 1;
# line 267 "EnsembleTrajectoryScan.st"
			seqg_var->loadingTrajectory = 0;
			pVar->status = writeRead(ssId, pVar, "getparm(125)", pVar->stringIn);
# line 271 "EnsembleTrajectoryScan.st"
			if (seqg_var->stringIn[0] == '%')
			{
# line 272 "EnsembleTrajectoryScan.st"
				seqg_var->numGlobalDoubles = atol(&seqg_var->stringIn[1]);
			}
			else
			{
				/* C code definitions */
# line 275 "EnsembleTrajectoryScan.st"
				pVar->status = writeRead(ssId, pVar, "getparm(@0,125)", pVar->stringIn);
# line 276 "EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 277 "EnsembleTrajectoryScan.st"
					seqg_var->numGlobalDoubles = atol(&seqg_var->stringIn[1]);
				}
				else
				{
# line 279 "EnsembleTrajectoryScan.st"
					printf("Can't read number of global doubles.  Motor controller problem?\n");
# line 280 "EnsembleTrajectoryScan.st"
					seqg_var->numGlobalDoubles = 0;
				}
			}
			pVar->status = writeRead(ssId, pVar, "getparm(124)", pVar->stringIn);
# line 286 "EnsembleTrajectoryScan.st"
			if (seqg_var->stringIn[0] == '%')
			{
# line 287 "EnsembleTrajectoryScan.st"
				seqg_var->numGlobalIntegers = atol(&seqg_var->stringIn[1]);
			}
			else
			{
				/* C code definitions */
# line 290 "EnsembleTrajectoryScan.st"
				pVar->status = writeRead(ssId, pVar, "getparm(@0,124)", pVar->stringIn);
# line 291 "EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 292 "EnsembleTrajectoryScan.st"
					seqg_var->numGlobalIntegers = atol(&seqg_var->stringIn[1]);
				}
				else
				{
# line 294 "EnsembleTrajectoryScan.st"
					printf("Can't read number of global integers.  Motor controller problem?\n");
# line 295 "EnsembleTrajectoryScan.st"
					seqg_var->numGlobalIntegers = 0;
				}
			}
# line 298 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 298 "EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:init: done; going to 'monitor_inputs'\n");
		}
		return;
	}
}

/****** Code for state "monitor_inputs" in state set "EnsembleTrajectoryScan" ******/

/* Entry function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static void seqg_entry_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env)
{
# line 306 "EnsembleTrajectoryScan.st"
	if (seqg_var->debugLevel)
# line 306 "EnsembleTrajectoryScan.st"
		printf("EnsembleTrajectoryScan:monitor_inputs: entry\n");
}

/* Event function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 308 "EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, buildMon) && (seqg_var->build == 1) && (seqg_var->initStatus == 1))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 311 "EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, executeMon) && (seqg_var->execute == 1) && ((seqg_var->buildStatus == 1) || (seqg_var->buildStatus == 5)))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 314 "EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, readbackMon) && (seqg_var->readback == 1))
	{
		*seqg_pnst = 5;
		*seqg_ptrn = 2;
		return TRUE;
	}
# line 318 "EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, nelementsMon) && (seqg_var->nelements >= 1))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 3;
		return TRUE;
	}
# line 333 "EnsembleTrajectoryScan.st"
	if (seq_efTestAndClear(seqg_env, pulsePositionsMon))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 4;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_inputs" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_monitor_inputs(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	case 1:
		{
		}
		return;
	case 2:
		{
# line 315 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
# line 315 "EnsembleTrajectoryScan.st"
				printf("readback command detected\n");
		}
		return;
	case 3:
		{
# line 322 "EnsembleTrajectoryScan.st"
			if (seqg_var->nelements > (seqg_var->numGlobalDoubles / 3 - 3))
			{
# line 326 "EnsembleTrajectoryScan.st"
				seqg_var->nelements = seqg_var->numGlobalDoubles / 3 - 3;
# line 327 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 2/*nelements*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 329 "EnsembleTrajectoryScan.st"
			seqg_var->endPulses = seqg_var->nelements;
# line 330 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 5/*endPulses*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 4:
		{
# line 334 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 334 "EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan:monitor_inputs: pvGet(pulsePositions)\n");
# line 335 "EnsembleTrajectoryScan.st"
			epicsThreadSleep(1.);
# line 336 "EnsembleTrajectoryScan.st"
			seq_pvGetTmo(seqg_env, 73/*pulsePositions*/, DEFAULT, DEFAULT_TIMEOUT);
# line 337 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
			{
# line 338 "EnsembleTrajectoryScan.st"
				printf("EnsembleTrajectoryScan: new pulse positions detected\n");
# line 339 "EnsembleTrajectoryScan.st"
				printf("...%lf, %lf...\n", seqg_var->pulsePositions[0], seqg_var->pulsePositions[1]);
			}
# line 341 "EnsembleTrajectoryScan.st"
			seqg_var->pulsePositionsLoaded = 0;
# line 342 "EnsembleTrajectoryScan.st"
			seqg_var->numPulsePositionsLoaded = 0;
		}
		return;
	}
}

/****** Code for state "build" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "build" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_build(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "build" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_build(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 350 "EnsembleTrajectoryScan.st"
			seqg_var->buildState = 1;
# line 351 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 352 "EnsembleTrajectoryScan.st"
			seqg_var->buildStatus = 0;
# line 353 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 354 "EnsembleTrajectoryScan.st"
			epicsSnprintf(seqg_var->buildMessage, 40, "Building...");
# line 355 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 357 "EnsembleTrajectoryScan.st"
			seqg_var->buildStatus = 1;
# line 360 "EnsembleTrajectoryScan.st"
			if (seqg_var->timeMode == 0)
			{
# line 361 "EnsembleTrajectoryScan.st"
				seqg_var->dtime = seqg_var->time / (seqg_var->nelements - 1);
# line 362 "EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->nelements; seqg_var->i++)
# line 362 "EnsembleTrajectoryScan.st"
					seqg_var->timeTrajectory[seqg_var->i] = seqg_var->dtime;
# line 363 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 26/*timeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
			}
			else
			{
# line 365 "EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0 , seqg_var->time = 0.; seqg_var->i < seqg_var->nelements; seqg_var->i++)
				{
# line 366 "EnsembleTrajectoryScan.st"
					seqg_var->time += seqg_var->timeTrajectory[seqg_var->i];
				}
# line 368 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 8/*time*/, DEFAULT, DEFAULT_TIMEOUT);
			}
# line 371 "EnsembleTrajectoryScan.st"
			seqg_var->npoints = seqg_var->nelements;
# line 374 "EnsembleTrajectoryScan.st"
			seqg_var->realTimeTrajectory[0] = 0.;
# line 375 "EnsembleTrajectoryScan.st"
			for (seqg_var->i = 1; seqg_var->i < seqg_var->npoints; seqg_var->i++)
			{
# line 376 "EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1] + seqg_var->timeTrajectory[seqg_var->i];
			}
# line 378 "EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->npoints; seqg_var->i++)
# line 378 "EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] *= seqg_var->timeScale;
# line 381 "EnsembleTrajectoryScan.st"
			for (; seqg_var->i < 1000; seqg_var->i++)
# line 381 "EnsembleTrajectoryScan.st"
				seqg_var->realTimeTrajectory[seqg_var->i] = seqg_var->realTimeTrajectory[seqg_var->i - 1];
# line 382 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 29/*realTimeTrajectory*/, DEFAULT, DEFAULT_TIMEOUT);
# line 385 "EnsembleTrajectoryScan.st"
			seqg_var->n = sprintf(seqg_var->abortCommand, "ABORT");
# line 386 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 387 "EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
					/* C code definitions */
# line 388 "EnsembleTrajectoryScan.st"
					buildTrajectory(ssId, pVar, pVar->realTimeTrajectory, pVar->motorTrajectory[pVar->j],
# line 389 "EnsembleTrajectoryScan.st"
					pVar->epicsMotorDir[pVar->j], pVar->moveMode, pVar->npoints, pVar->npulses,
# line 390 "EnsembleTrajectoryScan.st"
					pVar->epicsMotorOff[pVar->j], pVar->epicsMotorMres[pVar->j], pVar->velocity[pVar->j]);
# line 391 "EnsembleTrajectoryScan.st"
					seqg_var->n += sprintf(&seqg_var->abortCommand[seqg_var->n], " @%d", seqg_var->j);
				}
			}
# line 396 "EnsembleTrajectoryScan.st"
			seqg_var->expectedTime = seqg_var->realTimeTrajectory[seqg_var->npoints - 1];
# line 399 "EnsembleTrajectoryScan.st"
			seqg_var->limitViolation = 0;
# line 400 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes && !seqg_var->limitViolation; seqg_var->j++)
			{
# line 401 "EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 402 "EnsembleTrajectoryScan.st"
					seqg_var->vmax = seqg_var->epicsMotorVMAX[seqg_var->j];
# line 403 "EnsembleTrajectoryScan.st"
					if (fabs(seqg_var->vmax) < .001)
# line 403 "EnsembleTrajectoryScan.st"
						seqg_var->vmax = seqg_var->epicsMotorVELO[seqg_var->j];
# line 404 "EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel > 1)
# line 404 "EnsembleTrajectoryScan.st"
						printf("vmax=%f\n", seqg_var->vmax);
# line 405 "EnsembleTrajectoryScan.st"
					seqg_var->amax = seqg_var->vmax / seqg_var->epicsMotorACCL[seqg_var->j];
# line 406 "EnsembleTrajectoryScan.st"
					seqg_var->motorMVA[seqg_var->j] = 0.;
# line 407 "EnsembleTrajectoryScan.st"
					seqg_var->motorMAA[seqg_var->j] = 0.;
# line 408 "EnsembleTrajectoryScan.st"
					for (seqg_var->k = 0; seqg_var->k < seqg_var->npoints && !seqg_var->limitViolation; seqg_var->k++)
					{
# line 409 "EnsembleTrajectoryScan.st"
						seqg_var->posActual = seqg_var->motorTrajectory[seqg_var->j][seqg_var->k];
# line 410 "EnsembleTrajectoryScan.st"
						if (seqg_var->moveMode != 1)
# line 410 "EnsembleTrajectoryScan.st"
							seqg_var->posActual += seqg_var->epicsMotorPos[seqg_var->j];
# line 411 "EnsembleTrajectoryScan.st"
						seqg_var->limitViolation |= (seqg_var->posActual > seqg_var->epicsMotorHLM[seqg_var->j]) || (seqg_var->posActual < seqg_var->epicsMotorLLM[seqg_var->j]);
# line 412 "EnsembleTrajectoryScan.st"
						if (seqg_var->limitViolation)
						{
# line 413 "EnsembleTrajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "Limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->posActual);
						}
# line 415 "EnsembleTrajectoryScan.st"
						if (seqg_var->velocity[seqg_var->j][seqg_var->k] > seqg_var->vmax)
						{
# line 416 "EnsembleTrajectoryScan.st"
							seqg_var->limitViolation |= 1;
# line 418 "EnsembleTrajectoryScan.st"
							epicsSnprintf(seqg_var->buildMessage, 40, "V limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->velocity[seqg_var->j][seqg_var->k]);
						}
# line 420 "EnsembleTrajectoryScan.st"
						if (seqg_var->k > 1)
						{
# line 421 "EnsembleTrajectoryScan.st"
							seqg_var->dtime = seqg_var->realTimeTrajectory[seqg_var->k] - seqg_var->realTimeTrajectory[seqg_var->k - 1];
# line 422 "EnsembleTrajectoryScan.st"
							seqg_var->d = (seqg_var->velocity[seqg_var->j][seqg_var->k] - seqg_var->velocity[seqg_var->j][seqg_var->k - 1]) / seqg_var->dtime;
# line 423 "EnsembleTrajectoryScan.st"
							if (fabs(seqg_var->d) > seqg_var->amax)
							{
# line 424 "EnsembleTrajectoryScan.st"
								seqg_var->limitViolation |= 1;
# line 425 "EnsembleTrajectoryScan.st"
								epicsSnprintf(seqg_var->buildMessage, 40, "A limit: m%d at pt. %d (%f)", seqg_var->j + 1, seqg_var->k + 1, seqg_var->d);
							}
# line 427 "EnsembleTrajectoryScan.st"
							if ((seqg_var->dtime < .03) && (seqg_var->buildStatus != 5))
							{
# line 428 "EnsembleTrajectoryScan.st"
								seqg_var->buildStatus = 5;
# line 429 "EnsembleTrajectoryScan.st"
								epicsSnprintf(seqg_var->buildMessage, 40, "!! deltaT(=%.3f) < .03 at pt. %d", seqg_var->dtime, seqg_var->k + 1);
							}
						}
# line 432 "EnsembleTrajectoryScan.st"
						seqg_var->motorMVA[seqg_var->j] = ((seqg_var->motorMVA[seqg_var->j]) > (fabs(seqg_var->velocity[seqg_var->j][seqg_var->k])) ? (seqg_var->motorMVA[seqg_var->j]) : (fabs(seqg_var->velocity[seqg_var->j][seqg_var->k])));
					}
# line 435 "EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 141/*motorMVA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 436 "EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 157/*motorMAA*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
				}
			}
# line 439 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 1)
# line 439 "EnsembleTrajectoryScan.st"
				printf("limitViolation=%d\n", seqg_var->limitViolation);
# line 440 "EnsembleTrajectoryScan.st"
			if (seqg_var->limitViolation)
			{
# line 441 "EnsembleTrajectoryScan.st"
				seqg_var->buildStatus = 2;
			}
# line 447 "EnsembleTrajectoryScan.st"
			seqg_var->buildState = 0;
# line 448 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 13/*buildState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 449 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 14/*buildStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 450 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 453 "EnsembleTrajectoryScan.st"
			seqg_var->build = 0;
# line 454 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 12/*build*/, DEFAULT, DEFAULT_TIMEOUT);
# line 455 "EnsembleTrajectoryScan.st"
			if (seqg_var->buildStatus == 1)
			{
# line 456 "EnsembleTrajectoryScan.st"
				epicsSnprintf(seqg_var->buildMessage, 40, "Done");
# line 457 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 15/*buildMessage*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

/****** Code for state "execute" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "execute" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "execute" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 465 "EnsembleTrajectoryScan.st"
			seqg_var->execState = 1;
# line 466 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 467 "EnsembleTrajectoryScan.st"
			seqg_var->abortState = 0;
# line 468 "EnsembleTrajectoryScan.st"
			seqg_var->execStatus = 0;
# line 469 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 471 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 472 "EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 8000; seqg_var->i++)
				{
# line 473 "EnsembleTrajectoryScan.st"
					seqg_var->motorReadbacks[seqg_var->j][seqg_var->i] = 0.;
# line 474 "EnsembleTrajectoryScan.st"
					seqg_var->motorError[seqg_var->j][seqg_var->i] = 0.;
				}
			}
# line 478 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 479 "EnsembleTrajectoryScan.st"
				seqg_var->initialPos[seqg_var->j] = seqg_var->epicsMotorPos[seqg_var->j];
# line 480 "EnsembleTrajectoryScan.st"
				seqg_var->motorStart[seqg_var->j] = seqg_var->motorTrajectory[seqg_var->j][0] - (seqg_var->velocity[seqg_var->j][0] * seqg_var->epicsMotorACCL[seqg_var->j]) / 2;
# line 481 "EnsembleTrajectoryScan.st"
				if (seqg_var->moveMode != 1)
# line 481 "EnsembleTrajectoryScan.st"
					seqg_var->motorStart[seqg_var->j] += seqg_var->epicsMotorPos[seqg_var->j];
# line 482 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 62/*motorStart*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 485 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 486 "EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 487 "EnsembleTrajectoryScan.st"
					seqg_var->epicsMotorPos[seqg_var->j] = seqg_var->motorStart[seqg_var->j];
# line 488 "EnsembleTrajectoryScan.st"
					seq_pvPutTmo(seqg_env, 173/*epicsMotorPos*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 489 "EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel > 0)
# line 489 "EnsembleTrajectoryScan.st"
						printf("\nstate execute: moving motor %d to %f\n", seqg_var->j, seqg_var->epicsMotorPos[seqg_var->j]);
				}
			}
			waitEpicsMotors(ssId, pVar);
			getMotorPositions(ssId, pVar, pVar->motorCurr);
# line 496 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
			{
# line 497 "EnsembleTrajectoryScan.st"
				if (seqg_var->moveAxis[seqg_var->j])
				{
# line 498 "EnsembleTrajectoryScan.st"
					if (fabs(seqg_var->motorCurr[seqg_var->j] - seqg_var->motorStart[seqg_var->j]) > .01)
					{
# line 499 "EnsembleTrajectoryScan.st"
						printf("state execute: motor %d didn't move to start\n", seqg_var->j);
# line 500 "EnsembleTrajectoryScan.st"
						if (seqg_var->execStatus != 3)
						{
# line 501 "EnsembleTrajectoryScan.st"
							seqg_var->execStatus = 3;
							pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 503 "EnsembleTrajectoryScan.st"
							seqg_var->abortState = 2;
# line 504 "EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 504 "EnsembleTrajectoryScan.st"
								printf("abort: sent command '%s'\n", seqg_var->abortCommand);
						}
					}
				}
			}
# line 510 "EnsembleTrajectoryScan.st"
			if (seqg_var->execStatus != 3)
			{
				/* C code definitions */
# line 512 "EnsembleTrajectoryScan.st"
				getMotorPositions(ssId, pVar, pVar->motorStart);
# line 513 "EnsembleTrajectoryScan.st"
				epicsTimeGetCurrent(&lastPollTime);
# line 516 "EnsembleTrajectoryScan.st"
				seqg_var->elapsedTime = 0.;
# line 517 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
				epicsTimeGetCurrent(&startTime);
# line 519 "EnsembleTrajectoryScan.st"
				seqg_var->execState = 2;
# line 520 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 521 "EnsembleTrajectoryScan.st"
				for (seqg_var->j = 0 , seqg_var->movingMask = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 522 "EnsembleTrajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
# line 522 "EnsembleTrajectoryScan.st"
						seqg_var->movingMask |= (1 << seqg_var->j);
				}
# line 527 "EnsembleTrajectoryScan.st"
				for (seqg_var->i = 0; seqg_var->i < 10; seqg_var->i++)
				{
					/* C code definitions */
# line 528 "EnsembleTrajectoryScan.st"
					pVar->status = loadTrajectory(ssId, pVar);
# line 529 "EnsembleTrajectoryScan.st"
					if (seqg_var->status == -2)
					{
# line 530 "EnsembleTrajectoryScan.st"
						printf("Trying trajectory again\n");
					}
					else
					{
						break;
					}
				}
			}
		}
		return;
	}
}

/****** Code for state "wait_execute" in state set "EnsembleTrajectoryScan" ******/

/* Event function for state "wait_execute" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_wait_execute(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 542 "EnsembleTrajectoryScan.st"
	if (seqg_var->execStatus == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 554 "EnsembleTrajectoryScan.st"
	if ((seqg_var->execState == 2) && seq_delay(seqg_env, 0.1))
	{
		*seqg_pnst = 4;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 595 "EnsembleTrajectoryScan.st"
	if (seqg_var->execState == 3)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "wait_execute" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_wait_execute(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 546 "EnsembleTrajectoryScan.st"
			seqg_var->execState = 0;
# line 547 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 550 "EnsembleTrajectoryScan.st"
			seqg_var->execute = 0;
# line 551 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 1:
		{
			/* C code definitions */
# line 557 "EnsembleTrajectoryScan.st"
			epicsTimeGetCurrent(&currTime);
# line 558 "EnsembleTrajectoryScan.st"
			pVar->dtime = epicsTimeDiffInSeconds(&currTime, &lastPollTime);
# line 559 "EnsembleTrajectoryScan.st"
			if (seqg_var->dtime > (1 / 5.))
			{
				/* C code definitions */
# line 560 "EnsembleTrajectoryScan.st"
				pVar->elapsedTime = epicsTimeDiffInSeconds(&currTime, &startTime);
# line 561 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
				epicsTimeGetCurrent(&lastPollTime);
				getMotorPositions(ssId, pVar, pVar->motorCurrent);
# line 564 "EnsembleTrajectoryScan.st"
				for (seqg_var->j = 0; seqg_var->j < seqg_var->numAxes; seqg_var->j++)
				{
# line 565 "EnsembleTrajectoryScan.st"
					if (seqg_var->moveAxis[seqg_var->j])
					{
# line 566 "EnsembleTrajectoryScan.st"
						seq_pvPutTmo(seqg_env, 109/*motorCurrent*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
					}
				}
				pVar->anyMoving = getMotorMoving(ssId, pVar, pVar->movingMask);
# line 570 "EnsembleTrajectoryScan.st"
				if (seqg_var->anyMoving == 0)
				{
# line 571 "EnsembleTrajectoryScan.st"
					seqg_var->execState = 3;
# line 572 "EnsembleTrajectoryScan.st"
					seqg_var->execStatus = 1;
# line 573 "EnsembleTrajectoryScan.st"
					strcpy(seqg_var->execMessage, " ");
				}
# line 576 "EnsembleTrajectoryScan.st"
				if (seqg_var->elapsedTime > seqg_var->expectedTime * 2.)
				{
# line 577 "EnsembleTrajectoryScan.st"
					seqg_var->execState = 3;
# line 578 "EnsembleTrajectoryScan.st"
					seqg_var->execStatus = 4;
# line 579 "EnsembleTrajectoryScan.st"
					strcpy(seqg_var->execMessage, "Timeout");
					pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 583 "EnsembleTrajectoryScan.st"
					seqg_var->abortState = 2;
# line 584 "EnsembleTrajectoryScan.st"
					if (seqg_var->debugLevel)
# line 584 "EnsembleTrajectoryScan.st"
						printf("timeout: sent command '%s'\n", seqg_var->abortCommand);
# line 585 "EnsembleTrajectoryScan.st"
					strcpy(seqg_var->stringOut, "PROGRAM STOP 1");
					pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
					waitEpicsMotors(ssId, pVar); /* wait until all motors are done */
# line 589 "EnsembleTrajectoryScan.st"
					seqg_var->abortState = 3;
				}
			}
		}
		return;
	case 2:
		{
# line 596 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel > 2)
# line 596 "EnsembleTrajectoryScan.st"
				printf("flyback.\n");
# line 597 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 598 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 599 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 600 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 602 "EnsembleTrajectoryScan.st"
			if (seqg_var->pulseMode != 3)
			{
# line 603 "EnsembleTrajectoryScan.st"
				strcpy(seqg_var->stringOut, "PSOCONTROL @0 OFF");
				pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
			}
# line 606 "EnsembleTrajectoryScan.st"
			seqg_var->execState = 0;
# line 607 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 18/*execState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 610 "EnsembleTrajectoryScan.st"
			seqg_var->execute = 0;
# line 611 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 17/*execute*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "readback" in state set "EnsembleTrajectoryScan" ******/

/* Entry function for state "readback" in state set "EnsembleTrajectoryScan" */
static void seqg_entry_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env)
{
# line 618 "EnsembleTrajectoryScan.st"
	if (seqg_var->debugLevel)
# line 618 "EnsembleTrajectoryScan.st"
		printf("readback: entry\n");
}

/* Event function for state "readback" in state set "EnsembleTrajectoryScan" */
static seqBool seqg_event_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "readback" in state set "EnsembleTrajectoryScan" */
static void seqg_action_EnsembleTrajectoryScan_0_readback(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 622 "EnsembleTrajectoryScan.st"
			seqg_var->readState = 1;
# line 623 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 624 "EnsembleTrajectoryScan.st"
			seqg_var->readStatus = 0;
# line 625 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
			pVar->status = sendReceiveCommand(ssId, pVar, "SCOPETRIG STOP", pVar->stringIn, 1);
# line 629 "EnsembleTrajectoryScan.st"
			strcpy(seqg_var->stringLast, "");
# line 630 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 630 "EnsembleTrajectoryScan.st"
				printf("state readback: motorPosOffset[0]=%f\n", seqg_var->motorPosOffset[0]);
# line 631 "EnsembleTrajectoryScan.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->nScopeDataPoints; seqg_var->i++)
			{
# line 632 "EnsembleTrajectoryScan.st"
				if (seqg_var->execStatus == 3)
					break;
# line 633 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
				pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 635 "EnsembleTrajectoryScan.st"
				sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
				pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
# line 637 "EnsembleTrajectoryScan.st"
				if (seqg_var->stringIn[0] == '%')
				{
# line 638 "EnsembleTrajectoryScan.st"
					if (seqg_var->i == 0)
					{
# line 640 "EnsembleTrajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 10; seqg_var->j++)
						{
# line 641 "EnsembleTrajectoryScan.st"
							strcpy(seqg_var->stringLast, seqg_var->stringIn);
# line 642 "EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
							pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 644 "EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
							pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
# line 646 "EnsembleTrajectoryScan.st"
							if (strcmp(seqg_var->stringIn, seqg_var->stringLast) == 0)
								break;
# line 647 "EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 647 "EnsembleTrajectoryScan.st"
								printf("**%d\n", seqg_var->i);
						}
# line 649 "EnsembleTrajectoryScan.st"
						if (seqg_var->j == 10)
# line 649 "EnsembleTrajectoryScan.st"
							printf("abandoned read of point %d\n", seqg_var->i);
					}
					else
					{
# line 652 "EnsembleTrajectoryScan.st"
						for (seqg_var->j = 0; seqg_var->j < 10 && (strcmp(seqg_var->stringIn, seqg_var->stringLast) == 0); seqg_var->j++)
						{
# line 653 "EnsembleTrajectoryScan.st"
							if (seqg_var->debugLevel)
# line 653 "EnsembleTrajectoryScan.st"
								printf("**%d\n", seqg_var->i);
# line 654 "EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "SCOPEDATA %d %d", 1, seqg_var->i);
							pVar->status = sendReceiveCommand(ssId, pVar, pVar->stringOut, pVar->stringIn, 0);
# line 656 "EnsembleTrajectoryScan.st"
							sprintf(seqg_var->stringOut, "DGLOBAL(%d)", 1);
							pVar->status = writeRead(ssId, pVar, pVar->stringOut, pVar->stringIn);
						}
# line 659 "EnsembleTrajectoryScan.st"
						strcpy(seqg_var->stringLast, seqg_var->stringIn);
# line 660 "EnsembleTrajectoryScan.st"
						if (seqg_var->j == 10)
# line 660 "EnsembleTrajectoryScan.st"
							printf("abandoned read of point %d\n", seqg_var->i);
					}
# line 662 "EnsembleTrajectoryScan.st"
					seqg_var->k = atoi(&seqg_var->stringIn[1]);
					if (encoder_runs_backwards) pVar->k *= -1;
# line 664 "EnsembleTrajectoryScan.st"
					seqg_var->motorReadbacks[0][seqg_var->i] = seqg_var->k * seqg_var->epicsMotorMres[0] + seqg_var->motorPosOffset[0];
# line 665 "EnsembleTrajectoryScan.st"
					seqg_var->motorError[0][seqg_var->i] = seqg_var->motorReadbacks[0][seqg_var->i] - seqg_var->motorTrajectory[0][seqg_var->i];
				}
			}
# line 668 "EnsembleTrajectoryScan.st"
			for (; seqg_var->i < 8000; seqg_var->i++)
			{
# line 669 "EnsembleTrajectoryScan.st"
				seqg_var->motorReadbacks[0][seqg_var->i] = 0;
# line 670 "EnsembleTrajectoryScan.st"
				seqg_var->motorError[0][seqg_var->i] = 0;
			}
			pVar->d = trajEval(ssId, pVar, pVar->motorReadbacks[0], pVar->scopeDataIntervalMS, pVar->nScopeDataPoints,
			pVar->motorTrajectory[0], pVar->realTimeTrajectory, pVar->npoints, pVar->motorError[0]);
# line 697 "EnsembleTrajectoryScan.st"
			for (seqg_var->j = 0; seqg_var->j < 8; seqg_var->j++)
			{
# line 698 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 93/*motorReadbacks*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
# line 699 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 101/*motorError*/ + (CH_ID)(seqg_var->j), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 702 "EnsembleTrajectoryScan.st"
			seqg_var->readState = 0;
# line 703 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 23/*readState*/, DEFAULT, DEFAULT_TIMEOUT);
# line 705 "EnsembleTrajectoryScan.st"
			seqg_var->readStatus = 1;
# line 706 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 24/*readStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 707 "EnsembleTrajectoryScan.st"
			strcpy(seqg_var->readMessage, " ");
# line 708 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 25/*readMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 711 "EnsembleTrajectoryScan.st"
			seqg_var->readback = 0;
# line 712 "EnsembleTrajectoryScan.st"
			seq_pvPutTmo(seqg_env, 22/*readback*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "monitorAbort" in state set "trajectoryAbort" ******/

/* Event function for state "monitorAbort" in state set "trajectoryAbort" */
static seqBool seqg_event_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 723 "EnsembleTrajectoryScan.st"
	if (seq_efTest(seqg_env, abortMon) && (seqg_var->abort == 1) && seq_delay(seqg_env, 0.1))
	{
		*seqg_pnst = 0;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitorAbort" in state set "trajectoryAbort" */
static void seqg_action_trajectoryAbort_1_monitorAbort(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 724 "EnsembleTrajectoryScan.st"
			if (seqg_var->debugLevel)
# line 724 "EnsembleTrajectoryScan.st"
				printf("trajectoryAbort: loadingTrajectory=%d\n", seqg_var->loadingTrajectory);
# line 725 "EnsembleTrajectoryScan.st"
			seqg_var->abortState = 1;
# line 726 "EnsembleTrajectoryScan.st"
			if (!seqg_var->loadingTrajectory)
			{
# line 727 "EnsembleTrajectoryScan.st"
				seq_efClear(seqg_env, abortMon);
				pVar->status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
# line 729 "EnsembleTrajectoryScan.st"
				if (seqg_var->debugLevel)
# line 729 "EnsembleTrajectoryScan.st"
					printf("trajectoryAbort: sent command '%s'\n", seqg_var->abortCommand);
# line 730 "EnsembleTrajectoryScan.st"
				seqg_var->abortState = 2;
# line 732 "EnsembleTrajectoryScan.st"
				seqg_var->execStatus = 3;
# line 733 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 19/*execStatus*/, DEFAULT, DEFAULT_TIMEOUT);
# line 734 "EnsembleTrajectoryScan.st"
				strcpy(seqg_var->execMessage, "Abort command sent");
# line 735 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 20/*execMessage*/, DEFAULT, DEFAULT_TIMEOUT);
# line 736 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 28/*elapsedTime*/, DEFAULT, DEFAULT_TIMEOUT);
# line 739 "EnsembleTrajectoryScan.st"
				seqg_var->abort = 0;
# line 740 "EnsembleTrajectoryScan.st"
				seq_pvPutTmo(seqg_env, 21/*abort*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}{R}DebugLevel.VAL", offsetof(struct seqg_vars, debugLevel), "debugLevel", P_INT, 1, 9, 0, 1, 0, 0},
	{"{P}{R}NumAxes.VAL", offsetof(struct seqg_vars, numAxes), "numAxes", P_INT, 1, 10, 0, 1, 0, 0},
	{"{P}{R}Nelements.VAL", offsetof(struct seqg_vars, nelements), "nelements", P_INT, 1, 11, 7, 1, 0, 0},
	{"{P}{R}Npulses.VAL", offsetof(struct seqg_vars, npulses), "npulses", P_INT, 1, 12, 0, 1, 0, 0},
	{"{P}{R}StartPulses.VAL", offsetof(struct seqg_vars, startPulses), "startPulses", P_INT, 1, 13, 0, 1, 0, 0},
	{"{P}{R}EndPulses.VAL", offsetof(struct seqg_vars, endPulses), "endPulses", P_INT, 1, 14, 0, 1, 0, 0},
	{"{P}{R}Nactual.VAL", offsetof(struct seqg_vars, nactual), "nactual", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}{R}MoveMode.VAL", offsetof(struct seqg_vars, moveMode), "moveMode", P_INT, 1, 16, 0, 1, 0, 0},
	{"{P}{R}Time.VAL", offsetof(struct seqg_vars, time), "time", P_DOUBLE, 1, 17, 0, 1, 0, 0},
	{"{P}{R}TimeScale.VAL", offsetof(struct seqg_vars, timeScale), "timeScale", P_DOUBLE, 1, 18, 0, 1, 0, 0},
	{"{P}{R}TimeMode.VAL", offsetof(struct seqg_vars, timeMode), "timeMode", P_INT, 1, 19, 0, 1, 0, 0},
	{"{P}{R}Accel.VAL", offsetof(struct seqg_vars, accel), "accel", P_DOUBLE, 1, 20, 0, 1, 0, 0},
	{"{P}{R}Build.VAL", offsetof(struct seqg_vars, build), "build", P_INT, 1, 21, 2, 1, 0, 0},
	{"{P}{R}BuildState.VAL", offsetof(struct seqg_vars, buildState), "buildState", P_INT, 1, 22, 0, 0, 0, 0},
	{"{P}{R}BuildStatus.VAL", offsetof(struct seqg_vars, buildStatus), "buildStatus", P_INT, 1, 23, 0, 0, 0, 0},
	{"{P}{R}BuildMessage.VAL", offsetof(struct seqg_vars, buildMessage), "buildMessage", P_STRING, 1, 24, 0, 0, 0, 0},
	{"{P}{R}SimMode.VAL", offsetof(struct seqg_vars, simMode), "simMode", P_INT, 1, 25, 0, 1, 0, 0},
	{"{P}{R}Execute.VAL", offsetof(struct seqg_vars, execute), "execute", P_INT, 1, 26, 3, 1, 0, 0},
	{"{P}{R}ExecState.VAL", offsetof(struct seqg_vars, execState), "execState", P_INT, 1, 27, 4, 1, 0, 0},
	{"{P}{R}ExecStatus.VAL", offsetof(struct seqg_vars, execStatus), "execStatus", P_INT, 1, 28, 0, 0, 0, 0},
	{"{P}{R}ExecMessage.VAL", offsetof(struct seqg_vars, execMessage), "execMessage", P_STRING, 1, 29, 0, 0, 0, 0},
	{"{P}{R}Abort.VAL", offsetof(struct seqg_vars, abort), "abort", P_INT, 1, 30, 5, 1, 0, 0},
	{"{P}{R}Readback.VAL", offsetof(struct seqg_vars, readback), "readback", P_INT, 1, 31, 6, 1, 0, 0},
	{"{P}{R}ReadState.VAL", offsetof(struct seqg_vars, readState), "readState", P_INT, 1, 32, 0, 0, 0, 0},
	{"{P}{R}ReadStatus.VAL", offsetof(struct seqg_vars, readStatus), "readStatus", P_INT, 1, 33, 0, 0, 0, 0},
	{"{P}{R}ReadMessage.VAL", offsetof(struct seqg_vars, readMessage), "readMessage", P_STRING, 1, 34, 0, 0, 0, 0},
	{"{P}{R}TimeTraj.VAL", offsetof(struct seqg_vars, timeTrajectory), "timeTrajectory", P_DOUBLE, 1000, 35, 0, 1, 0, 0},
	{"{P}{R}TrajectoryFile.VAL", offsetof(struct seqg_vars, trajectoryFile), "trajectoryFile", P_STRING, 1, 36, 0, 1, 0, 0},
	{"{P}{R}ElapsedTime.VAL", offsetof(struct seqg_vars, elapsedTime), "elapsedTime", P_DOUBLE, 1, 37, 0, 0, 0, 0},
	{"{P}{R}realTimeTrajectory.VAL", offsetof(struct seqg_vars, realTimeTrajectory), "realTimeTrajectory", P_DOUBLE, 1000, 38, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[0]), "epicsMotorMres[0]", P_DOUBLE, 1, 39, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[1]), "epicsMotorMres[1]", P_DOUBLE, 1, 40, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[2]), "epicsMotorMres[2]", P_DOUBLE, 1, 41, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[3]), "epicsMotorMres[3]", P_DOUBLE, 1, 42, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[4]), "epicsMotorMres[4]", P_DOUBLE, 1, 43, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[5]), "epicsMotorMres[5]", P_DOUBLE, 1, 44, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[6]), "epicsMotorMres[6]", P_DOUBLE, 1, 45, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorMres[7]), "epicsMotorMres[7]", P_DOUBLE, 1, 46, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[0]), "epicsMotorCard[0]", P_INT, 1, 47, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[1]), "epicsMotorCard[1]", P_INT, 1, 48, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[2]), "epicsMotorCard[2]", P_INT, 1, 49, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[3]), "epicsMotorCard[3]", P_INT, 1, 50, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[4]), "epicsMotorCard[4]", P_INT, 1, 51, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[5]), "epicsMotorCard[5]", P_INT, 1, 52, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[6]), "epicsMotorCard[6]", P_INT, 1, 53, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorCard[7]), "epicsMotorCard[7]", P_INT, 1, 54, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[0]), "epicsMotorHLM[0]", P_DOUBLE, 1, 55, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[1]), "epicsMotorHLM[1]", P_DOUBLE, 1, 56, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[2]), "epicsMotorHLM[2]", P_DOUBLE, 1, 57, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[3]), "epicsMotorHLM[3]", P_DOUBLE, 1, 58, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[4]), "epicsMotorHLM[4]", P_DOUBLE, 1, 59, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[5]), "epicsMotorHLM[5]", P_DOUBLE, 1, 60, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[6]), "epicsMotorHLM[6]", P_DOUBLE, 1, 61, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorHLM[7]), "epicsMotorHLM[7]", P_DOUBLE, 1, 62, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[0]), "epicsMotorLLM[0]", P_DOUBLE, 1, 63, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[1]), "epicsMotorLLM[1]", P_DOUBLE, 1, 64, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[2]), "epicsMotorLLM[2]", P_DOUBLE, 1, 65, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[3]), "epicsMotorLLM[3]", P_DOUBLE, 1, 66, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[4]), "epicsMotorLLM[4]", P_DOUBLE, 1, 67, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[5]), "epicsMotorLLM[5]", P_DOUBLE, 1, 68, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[6]), "epicsMotorLLM[6]", P_DOUBLE, 1, 69, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorLLM[7]), "epicsMotorLLM[7]", P_DOUBLE, 1, 70, 0, 1, 0, 0},
	{"{P}{R}M1Start.VAL", offsetof(struct seqg_vars, motorStart[0]), "motorStart[0]", P_DOUBLE, 1, 71, 0, 0, 0, 0},
	{"{P}{R}M2Start.VAL", offsetof(struct seqg_vars, motorStart[1]), "motorStart[1]", P_DOUBLE, 1, 72, 0, 0, 0, 0},
	{"{P}{R}M3Start.VAL", offsetof(struct seqg_vars, motorStart[2]), "motorStart[2]", P_DOUBLE, 1, 73, 0, 0, 0, 0},
	{"{P}{R}M4Start.VAL", offsetof(struct seqg_vars, motorStart[3]), "motorStart[3]", P_DOUBLE, 1, 74, 0, 0, 0, 0},
	{"{P}{R}M5Start.VAL", offsetof(struct seqg_vars, motorStart[4]), "motorStart[4]", P_DOUBLE, 1, 75, 0, 0, 0, 0},
	{"{P}{R}M6Start.VAL", offsetof(struct seqg_vars, motorStart[5]), "motorStart[5]", P_DOUBLE, 1, 76, 0, 0, 0, 0},
	{"{P}{R}M7Start.VAL", offsetof(struct seqg_vars, motorStart[6]), "motorStart[6]", P_DOUBLE, 1, 77, 0, 0, 0, 0},
	{"{P}{R}M8Start.VAL", offsetof(struct seqg_vars, motorStart[7]), "motorStart[7]", P_DOUBLE, 1, 78, 0, 0, 0, 0},
	{"{P}{R}PulseDir", offsetof(struct seqg_vars, pulseDir), "pulseDir", P_INT, 1, 79, 0, 1, 0, 0},
	{"{P}{R}PulseLenUS", offsetof(struct seqg_vars, pulseLenUS), "pulseLenUS", P_DOUBLE, 1, 80, 0, 1, 0, 0},
	{"{P}{R}PulseSrc", offsetof(struct seqg_vars, pulseSrc), "pulseSrc", P_INT, 1, 81, 0, 1, 0, 0},
	{"{P}{R}PulsePositions.VAL", offsetof(struct seqg_vars, pulsePositions), "pulsePositions", P_DOUBLE, 8000, 82, 0, 0, 0, 0},
	{"{P}{R}NewPulsePositions.VAL", offsetof(struct seqg_vars, newPulsePositions), "newPulsePositions", P_DOUBLE, 1, 83, 1, 1, 0, 0},
	{"{P}{R}NumPulsePositions", offsetof(struct seqg_vars, numPulsePositions), "numPulsePositions", P_INT, 1, 84, 0, 1, 0, 0},
	{"{P}{R}PulseMode.VAL", offsetof(struct seqg_vars, pulseMode), "pulseMode", P_INT, 1, 85, 0, 1, 0, 0},
	{"{P}{R}M1Move.VAL", offsetof(struct seqg_vars, moveAxis[0]), "moveAxis[0]", P_INT, 1, 86, 0, 1, 0, 0},
	{"{P}{R}M2Move.VAL", offsetof(struct seqg_vars, moveAxis[1]), "moveAxis[1]", P_INT, 1, 87, 0, 1, 0, 0},
	{"{P}{R}M3Move.VAL", offsetof(struct seqg_vars, moveAxis[2]), "moveAxis[2]", P_INT, 1, 88, 0, 1, 0, 0},
	{"{P}{R}M4Move.VAL", offsetof(struct seqg_vars, moveAxis[3]), "moveAxis[3]", P_INT, 1, 89, 0, 1, 0, 0},
	{"{P}{R}M5Move.VAL", offsetof(struct seqg_vars, moveAxis[4]), "moveAxis[4]", P_INT, 1, 90, 0, 1, 0, 0},
	{"{P}{R}M6Move.VAL", offsetof(struct seqg_vars, moveAxis[5]), "moveAxis[5]", P_INT, 1, 91, 0, 1, 0, 0},
	{"{P}{R}M7Move.VAL", offsetof(struct seqg_vars, moveAxis[6]), "moveAxis[6]", P_INT, 1, 92, 0, 1, 0, 0},
	{"{P}{R}M8Move.VAL", offsetof(struct seqg_vars, moveAxis[7]), "moveAxis[7]", P_INT, 1, 93, 0, 1, 0, 0},
	{"{P}{R}M1Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[0]), "motorTrajectory[0]", P_DOUBLE, 1000, 94, 0, 1, 0, 0},
	{"{P}{R}M2Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[1]), "motorTrajectory[1]", P_DOUBLE, 1000, 95, 0, 1, 0, 0},
	{"{P}{R}M3Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[2]), "motorTrajectory[2]", P_DOUBLE, 1000, 96, 0, 1, 0, 0},
	{"{P}{R}M4Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[3]), "motorTrajectory[3]", P_DOUBLE, 1000, 97, 0, 1, 0, 0},
	{"{P}{R}M5Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[4]), "motorTrajectory[4]", P_DOUBLE, 1000, 98, 0, 1, 0, 0},
	{"{P}{R}M6Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[5]), "motorTrajectory[5]", P_DOUBLE, 1000, 99, 0, 1, 0, 0},
	{"{P}{R}M7Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[6]), "motorTrajectory[6]", P_DOUBLE, 1000, 100, 0, 1, 0, 0},
	{"{P}{R}M8Traj.VAL", offsetof(struct seqg_vars, motorTrajectory[7]), "motorTrajectory[7]", P_DOUBLE, 1000, 101, 0, 1, 0, 0},
	{"{P}{R}M1Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[0]), "motorReadbacks[0]", P_DOUBLE, 8000, 102, 0, 0, 0, 0},
	{"{P}{R}M2Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[1]), "motorReadbacks[1]", P_DOUBLE, 8000, 103, 0, 0, 0, 0},
	{"{P}{R}M3Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[2]), "motorReadbacks[2]", P_DOUBLE, 8000, 104, 0, 0, 0, 0},
	{"{P}{R}M4Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[3]), "motorReadbacks[3]", P_DOUBLE, 8000, 105, 0, 0, 0, 0},
	{"{P}{R}M5Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[4]), "motorReadbacks[4]", P_DOUBLE, 8000, 106, 0, 0, 0, 0},
	{"{P}{R}M6Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[5]), "motorReadbacks[5]", P_DOUBLE, 8000, 107, 0, 0, 0, 0},
	{"{P}{R}M7Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[6]), "motorReadbacks[6]", P_DOUBLE, 8000, 108, 0, 0, 0, 0},
	{"{P}{R}M8Actual.VAL", offsetof(struct seqg_vars, motorReadbacks[7]), "motorReadbacks[7]", P_DOUBLE, 8000, 109, 0, 0, 0, 0},
	{"{P}{R}M1Error.VAL", offsetof(struct seqg_vars, motorError[0]), "motorError[0]", P_DOUBLE, 8000, 110, 0, 0, 0, 0},
	{"{P}{R}M2Error.VAL", offsetof(struct seqg_vars, motorError[1]), "motorError[1]", P_DOUBLE, 8000, 111, 0, 0, 0, 0},
	{"{P}{R}M3Error.VAL", offsetof(struct seqg_vars, motorError[2]), "motorError[2]", P_DOUBLE, 8000, 112, 0, 0, 0, 0},
	{"{P}{R}M4Error.VAL", offsetof(struct seqg_vars, motorError[3]), "motorError[3]", P_DOUBLE, 8000, 113, 0, 0, 0, 0},
	{"{P}{R}M5Error.VAL", offsetof(struct seqg_vars, motorError[4]), "motorError[4]", P_DOUBLE, 8000, 114, 0, 0, 0, 0},
	{"{P}{R}M6Error.VAL", offsetof(struct seqg_vars, motorError[5]), "motorError[5]", P_DOUBLE, 8000, 115, 0, 0, 0, 0},
	{"{P}{R}M7Error.VAL", offsetof(struct seqg_vars, motorError[6]), "motorError[6]", P_DOUBLE, 8000, 116, 0, 0, 0, 0},
	{"{P}{R}M8Error.VAL", offsetof(struct seqg_vars, motorError[7]), "motorError[7]", P_DOUBLE, 8000, 117, 0, 0, 0, 0},
	{"{P}{R}M1Current.VAL", offsetof(struct seqg_vars, motorCurrent[0]), "motorCurrent[0]", P_DOUBLE, 1, 118, 0, 0, 0, 0},
	{"{P}{R}M2Current.VAL", offsetof(struct seqg_vars, motorCurrent[1]), "motorCurrent[1]", P_DOUBLE, 1, 119, 0, 0, 0, 0},
	{"{P}{R}M3Current.VAL", offsetof(struct seqg_vars, motorCurrent[2]), "motorCurrent[2]", P_DOUBLE, 1, 120, 0, 0, 0, 0},
	{"{P}{R}M4Current.VAL", offsetof(struct seqg_vars, motorCurrent[3]), "motorCurrent[3]", P_DOUBLE, 1, 121, 0, 0, 0, 0},
	{"{P}{R}M5Current.VAL", offsetof(struct seqg_vars, motorCurrent[4]), "motorCurrent[4]", P_DOUBLE, 1, 122, 0, 0, 0, 0},
	{"{P}{R}M6Current.VAL", offsetof(struct seqg_vars, motorCurrent[5]), "motorCurrent[5]", P_DOUBLE, 1, 123, 0, 0, 0, 0},
	{"{P}{R}M7Current.VAL", offsetof(struct seqg_vars, motorCurrent[6]), "motorCurrent[6]", P_DOUBLE, 1, 124, 0, 0, 0, 0},
	{"{P}{R}M8Current.VAL", offsetof(struct seqg_vars, motorCurrent[7]), "motorCurrent[7]", P_DOUBLE, 1, 125, 0, 0, 0, 0},
	{"{P}{R}M1MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[0]), "motorMDVS[0]", P_DOUBLE, 1, 126, 8, 1, 0, 0},
	{"{P}{R}M2MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[1]), "motorMDVS[1]", P_DOUBLE, 1, 127, 8, 1, 0, 0},
	{"{P}{R}M3MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[2]), "motorMDVS[2]", P_DOUBLE, 1, 128, 8, 1, 0, 0},
	{"{P}{R}M4MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[3]), "motorMDVS[3]", P_DOUBLE, 1, 129, 8, 1, 0, 0},
	{"{P}{R}M5MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[4]), "motorMDVS[4]", P_DOUBLE, 1, 130, 8, 1, 0, 0},
	{"{P}{R}M6MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[5]), "motorMDVS[5]", P_DOUBLE, 1, 131, 8, 1, 0, 0},
	{"{P}{R}M7MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[6]), "motorMDVS[6]", P_DOUBLE, 1, 132, 8, 1, 0, 0},
	{"{P}{R}M8MDVS.VAL", offsetof(struct seqg_vars, motorMDVS[7]), "motorMDVS[7]", P_DOUBLE, 1, 133, 8, 1, 0, 0},
	{"{P}{R}M1MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[0]), "motorMDVA[0]", P_DOUBLE, 1, 134, 0, 0, 0, 0},
	{"{P}{R}M2MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[1]), "motorMDVA[1]", P_DOUBLE, 1, 135, 0, 0, 0, 0},
	{"{P}{R}M3MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[2]), "motorMDVA[2]", P_DOUBLE, 1, 136, 0, 0, 0, 0},
	{"{P}{R}M4MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[3]), "motorMDVA[3]", P_DOUBLE, 1, 137, 0, 0, 0, 0},
	{"{P}{R}M5MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[4]), "motorMDVA[4]", P_DOUBLE, 1, 138, 0, 0, 0, 0},
	{"{P}{R}M6MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[5]), "motorMDVA[5]", P_DOUBLE, 1, 139, 0, 0, 0, 0},
	{"{P}{R}M7MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[6]), "motorMDVA[6]", P_DOUBLE, 1, 140, 0, 0, 0, 0},
	{"{P}{R}M8MDVA.VAL", offsetof(struct seqg_vars, motorMDVA[7]), "motorMDVA[7]", P_DOUBLE, 1, 141, 0, 0, 0, 0},
	{"{P}{R}M1MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[0]), "motorMDVE[0]", P_INT, 1, 142, 0, 0, 0, 0},
	{"{P}{R}M2MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[1]), "motorMDVE[1]", P_INT, 1, 143, 0, 0, 0, 0},
	{"{P}{R}M3MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[2]), "motorMDVE[2]", P_INT, 1, 144, 0, 0, 0, 0},
	{"{P}{R}M4MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[3]), "motorMDVE[3]", P_INT, 1, 145, 0, 0, 0, 0},
	{"{P}{R}M5MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[4]), "motorMDVE[4]", P_INT, 1, 146, 0, 0, 0, 0},
	{"{P}{R}M6MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[5]), "motorMDVE[5]", P_INT, 1, 147, 0, 0, 0, 0},
	{"{P}{R}M7MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[6]), "motorMDVE[6]", P_INT, 1, 148, 0, 0, 0, 0},
	{"{P}{R}M8MDVE.VAL", offsetof(struct seqg_vars, motorMDVE[7]), "motorMDVE[7]", P_INT, 1, 149, 0, 0, 0, 0},
	{"{P}{R}M1MVA.VAL", offsetof(struct seqg_vars, motorMVA[0]), "motorMVA[0]", P_DOUBLE, 1, 150, 0, 0, 0, 0},
	{"{P}{R}M2MVA.VAL", offsetof(struct seqg_vars, motorMVA[1]), "motorMVA[1]", P_DOUBLE, 1, 151, 0, 0, 0, 0},
	{"{P}{R}M3MVA.VAL", offsetof(struct seqg_vars, motorMVA[2]), "motorMVA[2]", P_DOUBLE, 1, 152, 0, 0, 0, 0},
	{"{P}{R}M4MVA.VAL", offsetof(struct seqg_vars, motorMVA[3]), "motorMVA[3]", P_DOUBLE, 1, 153, 0, 0, 0, 0},
	{"{P}{R}M5MVA.VAL", offsetof(struct seqg_vars, motorMVA[4]), "motorMVA[4]", P_DOUBLE, 1, 154, 0, 0, 0, 0},
	{"{P}{R}M6MVA.VAL", offsetof(struct seqg_vars, motorMVA[5]), "motorMVA[5]", P_DOUBLE, 1, 155, 0, 0, 0, 0},
	{"{P}{R}M7MVA.VAL", offsetof(struct seqg_vars, motorMVA[6]), "motorMVA[6]", P_DOUBLE, 1, 156, 0, 0, 0, 0},
	{"{P}{R}M8MVA.VAL", offsetof(struct seqg_vars, motorMVA[7]), "motorMVA[7]", P_DOUBLE, 1, 157, 0, 0, 0, 0},
	{"{P}{R}M1MVE.VAL", offsetof(struct seqg_vars, motorMVE[0]), "motorMVE[0]", P_INT, 1, 158, 0, 0, 0, 0},
	{"{P}{R}M2MVE.VAL", offsetof(struct seqg_vars, motorMVE[1]), "motorMVE[1]", P_INT, 1, 159, 0, 0, 0, 0},
	{"{P}{R}M3MVE.VAL", offsetof(struct seqg_vars, motorMVE[2]), "motorMVE[2]", P_INT, 1, 160, 0, 0, 0, 0},
	{"{P}{R}M4MVE.VAL", offsetof(struct seqg_vars, motorMVE[3]), "motorMVE[3]", P_INT, 1, 161, 0, 0, 0, 0},
	{"{P}{R}M5MVE.VAL", offsetof(struct seqg_vars, motorMVE[4]), "motorMVE[4]", P_INT, 1, 162, 0, 0, 0, 0},
	{"{P}{R}M6MVE.VAL", offsetof(struct seqg_vars, motorMVE[5]), "motorMVE[5]", P_INT, 1, 163, 0, 0, 0, 0},
	{"{P}{R}M7MVE.VAL", offsetof(struct seqg_vars, motorMVE[6]), "motorMVE[6]", P_INT, 1, 164, 0, 0, 0, 0},
	{"{P}{R}M8MVE.VAL", offsetof(struct seqg_vars, motorMVE[7]), "motorMVE[7]", P_INT, 1, 165, 0, 0, 0, 0},
	{"{P}{R}M1MAA.VAL", offsetof(struct seqg_vars, motorMAA[0]), "motorMAA[0]", P_DOUBLE, 1, 166, 0, 0, 0, 0},
	{"{P}{R}M2MAA.VAL", offsetof(struct seqg_vars, motorMAA[1]), "motorMAA[1]", P_DOUBLE, 1, 167, 0, 0, 0, 0},
	{"{P}{R}M3MAA.VAL", offsetof(struct seqg_vars, motorMAA[2]), "motorMAA[2]", P_DOUBLE, 1, 168, 0, 0, 0, 0},
	{"{P}{R}M4MAA.VAL", offsetof(struct seqg_vars, motorMAA[3]), "motorMAA[3]", P_DOUBLE, 1, 169, 0, 0, 0, 0},
	{"{P}{R}M5MAA.VAL", offsetof(struct seqg_vars, motorMAA[4]), "motorMAA[4]", P_DOUBLE, 1, 170, 0, 0, 0, 0},
	{"{P}{R}M6MAA.VAL", offsetof(struct seqg_vars, motorMAA[5]), "motorMAA[5]", P_DOUBLE, 1, 171, 0, 0, 0, 0},
	{"{P}{R}M7MAA.VAL", offsetof(struct seqg_vars, motorMAA[6]), "motorMAA[6]", P_DOUBLE, 1, 172, 0, 0, 0, 0},
	{"{P}{R}M8MAA.VAL", offsetof(struct seqg_vars, motorMAA[7]), "motorMAA[7]", P_DOUBLE, 1, 173, 0, 0, 0, 0},
	{"{P}{R}M1MAE.VAL", offsetof(struct seqg_vars, motorMAE[0]), "motorMAE[0]", P_INT, 1, 174, 0, 0, 0, 0},
	{"{P}{R}M2MAE.VAL", offsetof(struct seqg_vars, motorMAE[1]), "motorMAE[1]", P_INT, 1, 175, 0, 0, 0, 0},
	{"{P}{R}M3MAE.VAL", offsetof(struct seqg_vars, motorMAE[2]), "motorMAE[2]", P_INT, 1, 176, 0, 0, 0, 0},
	{"{P}{R}M4MAE.VAL", offsetof(struct seqg_vars, motorMAE[3]), "motorMAE[3]", P_INT, 1, 177, 0, 0, 0, 0},
	{"{P}{R}M5MAE.VAL", offsetof(struct seqg_vars, motorMAE[4]), "motorMAE[4]", P_INT, 1, 178, 0, 0, 0, 0},
	{"{P}{R}M6MAE.VAL", offsetof(struct seqg_vars, motorMAE[5]), "motorMAE[5]", P_INT, 1, 179, 0, 0, 0, 0},
	{"{P}{R}M7MAE.VAL", offsetof(struct seqg_vars, motorMAE[6]), "motorMAE[6]", P_INT, 1, 180, 0, 0, 0, 0},
	{"{P}{R}M8MAE.VAL", offsetof(struct seqg_vars, motorMAE[7]), "motorMAE[7]", P_INT, 1, 181, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[0]), "epicsMotorPos[0]", P_DOUBLE, 1, 182, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[1]), "epicsMotorPos[1]", P_DOUBLE, 1, 183, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[2]), "epicsMotorPos[2]", P_DOUBLE, 1, 184, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[3]), "epicsMotorPos[3]", P_DOUBLE, 1, 185, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[4]), "epicsMotorPos[4]", P_DOUBLE, 1, 186, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[5]), "epicsMotorPos[5]", P_DOUBLE, 1, 187, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[6]), "epicsMotorPos[6]", P_DOUBLE, 1, 188, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorPos[7]), "epicsMotorPos[7]", P_DOUBLE, 1, 189, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[0]), "epicsMotorDir[0]", P_INT, 1, 190, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[1]), "epicsMotorDir[1]", P_INT, 1, 191, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[2]), "epicsMotorDir[2]", P_INT, 1, 192, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[3]), "epicsMotorDir[3]", P_INT, 1, 193, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[4]), "epicsMotorDir[4]", P_INT, 1, 194, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[5]), "epicsMotorDir[5]", P_INT, 1, 195, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[6]), "epicsMotorDir[6]", P_INT, 1, 196, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDir[7]), "epicsMotorDir[7]", P_INT, 1, 197, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[0]), "epicsMotorOff[0]", P_DOUBLE, 1, 198, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[1]), "epicsMotorOff[1]", P_DOUBLE, 1, 199, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[2]), "epicsMotorOff[2]", P_DOUBLE, 1, 200, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[3]), "epicsMotorOff[3]", P_DOUBLE, 1, 201, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[4]), "epicsMotorOff[4]", P_DOUBLE, 1, 202, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[5]), "epicsMotorOff[5]", P_DOUBLE, 1, 203, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[6]), "epicsMotorOff[6]", P_DOUBLE, 1, 204, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorOff[7]), "epicsMotorOff[7]", P_DOUBLE, 1, 205, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[0]), "epicsMotorDone[0]", P_DOUBLE, 1, 206, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[1]), "epicsMotorDone[1]", P_DOUBLE, 1, 207, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[2]), "epicsMotorDone[2]", P_DOUBLE, 1, 208, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[3]), "epicsMotorDone[3]", P_DOUBLE, 1, 209, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[4]), "epicsMotorDone[4]", P_DOUBLE, 1, 210, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[5]), "epicsMotorDone[5]", P_DOUBLE, 1, 211, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[6]), "epicsMotorDone[6]", P_DOUBLE, 1, 212, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorDone[7]), "epicsMotorDone[7]", P_DOUBLE, 1, 213, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[0]), "epicsMotorVELO[0]", P_DOUBLE, 1, 214, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[1]), "epicsMotorVELO[1]", P_DOUBLE, 1, 215, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[2]), "epicsMotorVELO[2]", P_DOUBLE, 1, 216, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[3]), "epicsMotorVELO[3]", P_DOUBLE, 1, 217, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[4]), "epicsMotorVELO[4]", P_DOUBLE, 1, 218, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[5]), "epicsMotorVELO[5]", P_DOUBLE, 1, 219, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[6]), "epicsMotorVELO[6]", P_DOUBLE, 1, 220, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVELO[7]), "epicsMotorVELO[7]", P_DOUBLE, 1, 221, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[0]), "epicsMotorVMAX[0]", P_DOUBLE, 1, 222, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[1]), "epicsMotorVMAX[1]", P_DOUBLE, 1, 223, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[2]), "epicsMotorVMAX[2]", P_DOUBLE, 1, 224, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[3]), "epicsMotorVMAX[3]", P_DOUBLE, 1, 225, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[4]), "epicsMotorVMAX[4]", P_DOUBLE, 1, 226, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[5]), "epicsMotorVMAX[5]", P_DOUBLE, 1, 227, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[6]), "epicsMotorVMAX[6]", P_DOUBLE, 1, 228, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMAX[7]), "epicsMotorVMAX[7]", P_DOUBLE, 1, 229, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[0]), "epicsMotorVMIN[0]", P_DOUBLE, 1, 230, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[1]), "epicsMotorVMIN[1]", P_DOUBLE, 1, 231, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[2]), "epicsMotorVMIN[2]", P_DOUBLE, 1, 232, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[3]), "epicsMotorVMIN[3]", P_DOUBLE, 1, 233, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[4]), "epicsMotorVMIN[4]", P_DOUBLE, 1, 234, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[5]), "epicsMotorVMIN[5]", P_DOUBLE, 1, 235, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[6]), "epicsMotorVMIN[6]", P_DOUBLE, 1, 236, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorVMIN[7]), "epicsMotorVMIN[7]", P_DOUBLE, 1, 237, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[0]), "epicsMotorACCL[0]", P_DOUBLE, 1, 238, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[1]), "epicsMotorACCL[1]", P_DOUBLE, 1, 239, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[2]), "epicsMotorACCL[2]", P_DOUBLE, 1, 240, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[3]), "epicsMotorACCL[3]", P_DOUBLE, 1, 241, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[4]), "epicsMotorACCL[4]", P_DOUBLE, 1, 242, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[5]), "epicsMotorACCL[5]", P_DOUBLE, 1, 243, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[6]), "epicsMotorACCL[6]", P_DOUBLE, 1, 244, 0, 1, 0, 0},
	{"", offsetof(struct seqg_vars, epicsMotorACCL[7]), "epicsMotorACCL[7]", P_DOUBLE, 1, 245, 0, 1, 0, 0},
};

/* Event masks for state set "EnsembleTrajectoryScan" */
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_init[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_monitor_inputs[] = {
	0x84a008ce,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_build[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_execute[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_wait_execute[] = {
	0x18000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};
static const seqMask seqg_mask_EnsembleTrajectoryScan_0_readback[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "EnsembleTrajectoryScan" */
static seqState seqg_states_EnsembleTrajectoryScan[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_init,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_inputs",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_monitor_inputs,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_monitor_inputs,
	/* entry function */    seqg_entry_EnsembleTrajectoryScan_0_monitor_inputs,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_monitor_inputs,
	/* state options */     (0)
	},
	{
	/* state name */        "build",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_build,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_build,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_build,
	/* state options */     (0)
	},
	{
	/* state name */        "execute",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_execute,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "wait_execute",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_wait_execute,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_wait_execute,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_wait_execute,
	/* state options */     (0)
	},
	{
	/* state name */        "readback",
	/* action function */   seqg_action_EnsembleTrajectoryScan_0_readback,
	/* event function */    seqg_event_EnsembleTrajectoryScan_0_readback,
	/* entry function */    seqg_entry_EnsembleTrajectoryScan_0_readback,
	/* exit function */     0,
	/* event mask array */  seqg_mask_EnsembleTrajectoryScan_0_readback,
	/* state options */     (0)
	},
};

/* Event masks for state set "trajectoryAbort" */
static const seqMask seqg_mask_trajectoryAbort_1_monitorAbort[] = {
	0x40000020,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

/* State table for state set "trajectoryAbort" */
static seqState seqg_states_trajectoryAbort[] = {
	{
	/* state name */        "monitorAbort",
	/* action function */   seqg_action_trajectoryAbort_1_monitorAbort,
	/* event function */    seqg_event_trajectoryAbort_1_monitorAbort,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_trajectoryAbort_1_monitorAbort,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "EnsembleTrajectoryScan",
	/* states */            seqg_states_EnsembleTrajectoryScan,
	/* number of states */  6
	},

	{
	/* state set name */    "trajectoryAbort",
	/* states */            seqg_states_trajectoryAbort,
	/* number of states */  1
	},
};

/* Program table (global) */
seqProgram EnsembleTrajectoryScan = {
	/* magic number */      2002002,
	/* program name */      "EnsembleTrajectoryScan",
	/* channels */          seqg_chans,
	/* num. channels */     237,
	/* state sets */        seqg_statesets,
	/* num. state sets */   2,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=13IDC:,R=traj1,M1=M1,M2=M2,M3=M3,M4=M4,M5=M5,M6=M6,M7=M7,M8=M8,PORT=serial1",
	/* num. event flags */  8,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 748 "EnsembleTrajectoryScan.st"


/* writeOnly sends a command to the Ensemble controller */
static int writeOnly(SS_ID ssId, struct UserVar *pVar, char *command)
{
	asynStatus status=0;
	int debug_out=0;
	size_t nwrite;
	char buffer[100];

	/* Copy command so we can add terminator */
	strncpy(buffer, command, 100-3);
	strcat(buffer, "\n");
	if (!(pVar->simMode)) {
		status = pasynOctetSyncIO->write((asynUser *)pVar->pasynUser, buffer,
							   strlen(buffer), 1.0, &nwrite);
	}
	if (pVar->execState==2)
		debug_out = (pVar->debugLevel >= 7);
	else
		debug_out = (pVar->debugLevel >= 2);
	if (pVar->simMode || debug_out) printf("    writeOnly:command='%s'\n", command);
	return(status);
}


/* writeRead sends a command to the Ensemble controller and reads the response into
 * the global character buffer, stringIn.
 */
static int writeRead(SS_ID ssId, struct UserVar *pVar, char *command, char *reply)
{
	asynStatus status=0;
	char buffer[100];
	size_t nwrite, nread;
	int eomReason;

	strncpy(buffer, command, 100-3);

	/*strcat(buffer, "\n");*/
	/* Use 30 second timeout, some commands take a long time to reply */
	if (!(pVar->simMode)) {
		status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, buffer,
							   strlen(buffer), reply, 100, 
							   30.0, &nwrite, &nread, &eomReason);
		if (status) printf("writeRead: pasynOctetSyncIO->writeRead returned %d\n", status);
	}
	if (pVar->simMode || (pVar->debugLevel >= 3)) {
		if (buffer[strlen(buffer)-1] == '\n') buffer[strlen(buffer)-1] = '\0';
		printf("    writeRead:command='%s', reply='%s'\n", buffer, reply);
	}
	return(status);
}


/* getMotorPositions returns the positions of each motor */

static int getMotorPositions(SS_ID ssId, struct UserVar *pVar, double *pos)
{
    int j, status;
    int dir, rawP;
	double rawF;
    char inputBuff[100], outputBuff[100];
	size_t nwrite, nread;
	int eomReason;

	for (j=0; j<pVar->numAxes; j++) {
		sprintf(outputBuff, "PFBKPROG(@%d)", j);
		status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, outputBuff,
							   strlen(outputBuff), inputBuff, 100, 
							   30.0, &nwrite, &nread, &eomReason);
		if (status) printf("getMotorPositions: pasynOctetSyncIO->writeRead returned %d\n", status);
		if (inputBuff[0] != '%')
			rawF = 0;
		else
			rawF = atof(&inputBuff[1]);
		rawP = rawF / fabs(pVar->epicsMotorMres[j]);
        if (pVar->epicsMotorDir[j] == 0) dir=1; else dir=-1;
		pos[j] = rawToUser(rawP, pVar->epicsMotorOff[j], dir, pVar->epicsMotorMres[j]);
    }

	if (pVar->debugLevel > 2) {
		printf("pos[0]=%.2f\n", pos[0]);
	}
	/*epicsThreadSleep(READ_INTERVAL);*/
	return(0);
}


/* getMotorMoving returns 1 if any of the motors in movingMask are moving */

static int getMotorMoving(SS_ID ssId, struct UserVar *pVar, int movingMask)
{
    char inputBuff[100], outputBuff[100];
	size_t nwrite, nread;
	int eomReason;
	int move_active;
	int i, count, status;

	sprintf(outputBuff, "PLANESTATUS(0)");

	for (i=0, count=0; i<1; i++) {
		status = pasynOctetSyncIO->writeRead((asynUser *)pVar->pasynUser, outputBuff,
							   strlen(outputBuff), inputBuff, 100, 
							   30.0, &nwrite, &nread, &eomReason);
		if (status) printf("getMotorMoving: pasynOctetSyncIO->writeRead returned %d\n", status);
		if (strlen(inputBuff) > 3) printf("getMotorMoving: PLANESTATUS(0) returned '%s'\n", inputBuff);
		if (pVar->debugLevel > 2) {
			printf("getMotorMoving: inputBuff='%s'\n", inputBuff);
		}
		move_active = atoi(&inputBuff[1]);
		if (move_active) {
			return(1);
		} else {
			count++;
			if (count>2) break;
		}
	}

	return(0);
}


/* getEpicsMotorMoving returns the EPICS moving status of each motor, packed into 
 * a single int.  Bit 0 = motor 1, bit 1 = motor 2, etc. 0=not moving, 1=moving.
 * If the entire int is 0 then no motors are moving */
static int getEpicsMotorMoving(SS_ID ssId, struct UserVar *pVar)
{
	int j;
	int result=0, mask=0x01;

	for (j=0; j<pVar->numAxes; j++) {
		seq_pvGet(ssId, pVar->epicsMotorDoneIndex[j], 0);
		if (pVar->epicsMotorDone[j] == 0) result |= mask;
		mask = mask << 1;
	}
	return(result);
}

/* waitEpicsMotors waits for all motors to stop moving using the EPICS motor
 * records..  It reads and posts the motor positions during each loop. */
static int waitEpicsMotors(SS_ID ssId, struct UserVar *pVar)
{
	int j;

	/* Logic is that we always want to post position motor positions 
	 * after the end of move is detected. */
	while (getEpicsMotorMoving(ssId, pVar)) {
		/* Get the current motor positions, post them */
		for (j=0; j<pVar->numAxes; j++) {
			pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
			seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
		}
		epicsThreadSleep((1/5.));
	}
	for (j=0; j<pVar->numAxes; j++) {
		pVar->motorCurrent[j] = pVar->epicsMotorPos[j];
		seq_pvPut(ssId, pVar->motorCurrentIndex[j], 0);
	}
	return(0);
}

/* Calculate velocities suitable for Ensemble PVT commands.
 * We're given x(t) in the form x[i], t[i].  We need to calculate v(x) that will produce x(t).
 * Assume someone else will take care of accelerating onto, and decelerating off of trajectory.
 */

static int buildTrajectory(SS_ID ssId, struct UserVar *pVar, double *realTimeTrajectory,
	double *motorTrajectory, int epicsMotorDir, int moveMode, int npoints, int npulses, double motorOffset,
	double motorResolution, double *velocity)
{
	double dp, dt, maxV=0;
	int i, status;
	char stringOut[100], reply[100];

	sprintf(stringOut, "GETPARM(%d)", 35);
	status = writeRead(ssId, pVar, stringOut, reply);

	if (reply[0] == '%') {
		maxV = atof(&reply[1]);
	} else {
		printf("buildTrajectory: Can't read velocityCommandThreshold parameter\n");
		return(-1);
	}



	for (i=0; i<npoints; i++) {
		if (i==0) {
			dp = motorTrajectory[1] - motorTrajectory[0];
			dt = realTimeTrajectory[1] - realTimeTrajectory[0];
			velocity[i] = dp/dt;
		} else {
			dp = motorTrajectory[i] - motorTrajectory[i-1];
			dt = realTimeTrajectory[i] - realTimeTrajectory[i-1];
			velocity[i] = 2*dp/dt - velocity[i-1];
		}
		if (pVar->debugLevel > 2) {
			printf("point %d: pos=%f, vel=%f, time=%f\n", i, motorTrajectory[i], velocity[i], realTimeTrajectory[i]);
		}
	}



















#line 968 "EnsembleTrajectoryScan.st"

	for (i=0; i<npoints; i++) {
		if (fabs(velocity[i]) > maxV) {
			printf("velocity > limit %f at point %d: vel=%f\n", maxV, i, velocity[i]);
			return(-1);
		}
	}

	return(0);
}

static int userToRaw(double user, double off, int dir, double res) {
	return ((int)(((user-off)*dir/res)>0 ? ((user-off)*dir/res)+0.5 : ((user-off)*dir/res)-0.5));
}

static double rawToUser(int raw, double off, int dir, double res) {
	/*printf("rawToUser: raw=%d, off=%f, dir=%d, res=%f, user=%f\n", raw, off, dir, res, raw*res*dir+off);*/
	return (raw*res*dir+off);
}





/* Many of the Ensemble commands needed for trajectories are not supported via the ASCII
 * interface, but must be executed from a precompiled AeroBasic program, which loadTrajectory()
 * has already started for us with the command "PROGRAM RUN 1 doCommand.bcx".  We get the
 * Aerobasic program to execute for us by setting Ensemble global variables to specify the
 * command and any arguments, and waiting for the AeroBasic program to notice, execute, and
 * reply by setting the command global variable back to 0.
 */
int sendReceiveCommand(SS_ID ssId, struct UserVar *pVar, char *cmd, char *callerReply, int checkProgram) {
	int i, i1, i2, i3, i4, cmdNum;
	double d1, d2, d3;
	char stringOut[100], reply[100];
	int status, saveDebug;

	if (pVar->debugLevel > 1) {
		printf("sendReceiveCommand: command='%s'\n", cmd);
	}
	if (checkProgram) {
		/* Caller doesn't know whether or not the Aerobasic "doCommand" program is running.  Check. */
		strcpy(stringOut, "TASKSTATE(1)");
		status = writeRead(ssId, pVar, stringOut, reply);
		status = atoi(&reply[1]);
		if (reply[0] == '!') {
			printf("sendReceiveCommand: 'TASKSTATE(1)' returned error.\n");
			return(-1);
		}
		switch (status) {
		case 0:
			if (strlen(reply) == 1) {
				printf("sendReceiveCommand: TASKSTATE(1)' returned '%s', which I'm ignoring\n", reply);
			} else {
				printf("sendReceiveCommand: TASKSTATE(1)' returned '%s'\n", reply);
				return(-1);
			}
			break;
		case 3: /* running */
			break;
		case 1:	/* idle */
		case 2: /* ready but not running */
		case 4: /* paused */
		case 5: /* done */
			strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
			status = writeRead(ssId, pVar, stringOut, reply);
			epicsThreadSleep(.1);
			break;
		case 6: /* in error */
			strcpy(stringOut, "PROGRAM STOP 1");
			status = writeRead(ssId, pVar, stringOut, reply);
			epicsThreadSleep(.1);
			strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
			status = writeRead(ssId, pVar, stringOut, reply);
			epicsThreadSleep(.1);
			break;
		default:
			/* do nothing */
			break;
		}
	}

	/* Nobody wants to see debug output from all these IGLOBAL commands, so depress the debugLevel. */
	saveDebug = pVar->debugLevel;
	pVar->debugLevel = ((0) > (pVar->debugLevel - 1) ? (0) : (pVar->debugLevel - 1));

	cmdNum = 0;
	if (strncmp(cmd, "VELOCITY ON", strlen("VELOCITY ON")) == 0) {
		cmdNum = 1;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 1);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "DOTRAJECTORY", strlen("DOTRAJECTORY")) == 0) {
		cmdNum = 25;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 25);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "VELOCITY OFF", strlen("VELOCITY OFF")) == 0) {
		cmdNum = 2;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 2);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "HALT", strlen("HALT")) == 0) {
		cmdNum = 3;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 3);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "STARTABORT", strlen("STARTABORT")) == 0) {
		cmdNum = 12;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 12);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "START", strlen("START")) == 0) {
		cmdNum = 4;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 4);
		if (callerReply != NULL) {
			status = writeRead(ssId, pVar, stringOut, reply);
		} else {
			status = writeOnly(ssId, pVar, stringOut);
		}
	} else if (strncmp(cmd, "PVT INIT TIME ABS", strlen("PVT INIT TIME ABS")) == 0) {
		cmdNum = 5;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 5);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "PVT INIT TIME INC", strlen("PVT INIT TIME INC")) == 0) {
		cmdNum = 6;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 6);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "PVT1", strlen("PVT1")) == 0) {
		cmdNum = 7;
		sscanf(cmd, "PVT1 %d %lf,%lf TIME %lf", &i1, &d1, &d2, &d3);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		status = writeDoubleAndCheck(ssId, pVar, 1, d1);
		status = writeDoubleAndCheck(ssId, pVar, 2, d2);
		status = writeDoubleAndCheck(ssId, pVar, 3, d3);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 7);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "ABORT", strlen("ABORT")) == 0) {
		cmdNum = 11;
		i1 = i2 = i3 = i4 = -1;
		i = sscanf(cmd, "ABORT @%d @%d @%d @%d", &i1, &i2, &i3, &i4);
		status = writeIntAndCheck(ssId, pVar, 44, i);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		status = writeIntAndCheck(ssId, pVar, 47, i2);
		status = writeIntAndCheck(ssId, pVar, 48, i3);
		status = writeIntAndCheck(ssId, pVar, 49, i4);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 11);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "SCOPEBUFFER", strlen("SCOPEBUFFER")) == 0) {
		cmdNum = 13;
		i1 = 0;
		i = sscanf(cmd, "SCOPEBUFFER %d", &i1);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 13);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "SCOPEDATA", strlen("SCOPEDATA")) == 0) {
		cmdNum = 14;
		i1 = i2 = 0;
		i = sscanf(cmd, "SCOPEDATA %d %d", &i1, &i2);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		status = writeIntAndCheck(ssId, pVar, 47, i2);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 14);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "SCOPESTATUS", strlen("SCOPESTATUS")) == 0) {
		cmdNum = 15;
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 15);
		status = writeRead(ssId, pVar, stringOut, reply);
		/* AeroBasic passes status back in IGLOBAL(iarg1Var) */
	} else if (strncmp(cmd, "SCOPETRIG STOP", strlen("SCOPETRIG STOP")) == 0) {
		cmdNum = 16;
		status = writeIntAndCheck(ssId, pVar, 46, 1);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 16);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "SCOPETRIGPERIOD", strlen("SCOPETRIGPERIOD")) == 0) {
		cmdNum = 17;
		/* Note period is in ms, though several faster rates are possible */
		i1 = 0;
		i = sscanf(cmd, "SCOPETRIGPERIOD %d", &i1);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 17);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "SCOPETRIG", strlen("SCOPETRIG")) == 0) {
		cmdNum = 16;
		status = writeIntAndCheck(ssId, pVar, 46, 0);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 16);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "LINEAR", strlen("LINEAR")) == 0) {
		cmdNum = 19;
		i1 = 0;
		d1 = d2 = 0;
		i = sscanf(cmd, "LINEAR @%d %lf F%lf", &i1, &d1, &d2);
		status = writeIntAndCheck(ssId, pVar, 46, i1);
		status = writeDoubleAndCheck(ssId, pVar, 1, d1);
		status = writeDoubleAndCheck(ssId, pVar, 2, d2);
		sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 19);
		status = writeRead(ssId, pVar, stringOut, reply);
	} else if (strncmp(cmd, "DATAACQ", strlen("DATAACQ")) == 0) {
		if (strncmp(cmd, "DATAACQ_TRIG", strlen("DATAACQ_TRIG")) == 0) {
			cmdNum = 20;
			i1 = i2 = 0;
			i = sscanf(cmd, "DATAACQ_TRIG @%d %d", &i1, &i2);
			status = writeIntAndCheck(ssId, pVar, 46, i1);
			status = writeIntAndCheck(ssId, pVar, 47, i2);
			sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 20);
			status = writeRead(ssId, pVar, stringOut, reply);
		} else if (strncmp(cmd, "DATAACQ_INP", strlen("DATAACQ_INP")) == 0) {
			cmdNum = 21;
			i1 = i2 = 0;
			i = sscanf(cmd, "DATAACQ_INP @%d %d", &i1, &i2);
			status = writeIntAndCheck(ssId, pVar, 46, i1);
			status = writeIntAndCheck(ssId, pVar, 47, i2);
			sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 21);
			status = writeRead(ssId, pVar, stringOut, reply);
		} else if (strncmp(cmd, "DATAACQ_ON", strlen("DATAACQ_ON")) == 0) {
			cmdNum = 22;
			i1 = i2 = 0;
			i = sscanf(cmd, "DATAACQ_ON @%d %d", &i1, &i2);
			status = writeIntAndCheck(ssId, pVar, 46, i1);
			status = writeIntAndCheck(ssId, pVar, 47, i2);
			sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 22);
			status = writeRead(ssId, pVar, stringOut, reply);
		} else if (strncmp(cmd, "DATAACQ_OFF", strlen("DATAACQ_OFF")) == 0) {
			cmdNum = 23;
			i1 = 0;
			i = sscanf(cmd, "DATAACQ_OFF @%d", &i1);
			status = writeIntAndCheck(ssId, pVar, 46, i1);
			sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 23);
			status = writeRead(ssId, pVar, stringOut, reply);
		} else if (strncmp(cmd, "DATAACQ_READ", strlen("DATAACQ_READ")) == 0) {
			cmdNum = 24;
			i1 = i2 = i3 = 0;
			i = sscanf(cmd, "DATAACQ_READ @%d %d %d", &i1, &i2, &i3);
			status = writeIntAndCheck(ssId, pVar, 46, i1);
			status = writeIntAndCheck(ssId, pVar, 47, i2);
			status = writeIntAndCheck(ssId, pVar, 48, i3);
			sprintf(stringOut, "IGLOBAL(%d) = %d", 45, 24);
			status = writeRead(ssId, pVar, stringOut, reply);
		} else {
			cmdNum = -1;
			printf("sendReceiveCommand: unexpected command: '%s'\n", cmd);
			return(-1);
		}
	}

	/* Wait for IGLOBAL(cmdVar) to be reset to zero, but don't wait for the "DOTRAJECTORY" command,
	 * because it doesn't complete until the trajectory has been executed.
	 */
	i = 0;
	if (cmdNum != 25) {
		sprintf(stringOut, "IGLOBAL(%d)", 45);
		for (i=0; i<300; i++) {
			status = writeRead(ssId, pVar, stringOut, reply);
			if (reply[0] == '%') {
				if (atoi(&reply[1]) == -cmdNum) break;
			} 
			epicsThreadSleep(0.01);
		}
	}
	pVar->debugLevel = saveDebug;

	if (i>300-1) {
		printf("sendReceiveCommand: timeout (%.2f s) executing '%s'; reply='%s'\n",
			300*0.01, cmd, reply);
		if (callerReply != NULL) {
			printf("... reply='%s'\n", reply);
		}
		/* clear cmdVar */
		status = writeIntAndCheck(ssId, pVar, 45, 0);
		return(-1);
	}
	return(0);
}

int writeDoubleAndCheck(SS_ID ssId, struct UserVar *pVar, int n, double d) {
	char stringOut[100], reply[100];
	double dCheck = -d;
	int i, status;
	
	for (i=0; i<10; i++) {
		sprintf(stringOut, "DGLOBAL(%d) = %f", n, d);
		status = writeRead(ssId, pVar, stringOut, reply);
		if (status) return(-1);
		sprintf(stringOut, "DGLOBAL(%d)", n);
		status = writeRead(ssId, pVar, stringOut, reply);
		if (status) return(-1);
		dCheck = atof(&reply[1]);
		if (fabs(d-dCheck) < .0001) break;
		printf("writeDoubleAndCheck: fix dglobal %d (%f != %f)\n", n, d, dCheck);
	}
	if (i==10) return(-1);
	return(0);
}

int writeIntAndCheck(SS_ID ssId, struct UserVar *pVar, int n, int ival) {
	char stringOut[100], reply[100];
	int iCheck = -ival;
	int i, status;
	
	for (i=0; i<10; i++) {
		sprintf(stringOut, "IGLOBAL(%d) = %d", n, ival);
		status = writeRead(ssId, pVar, stringOut, reply);
		if (status) return(-1);
		sprintf(stringOut, "IGLOBAL(%d)", n);
		status = writeRead(ssId, pVar, stringOut, reply);
		if (status) return(-1);
		iCheck = atol(&reply[1]);
		if (ival == iCheck) break;
		printf("writeIntAndCheck: fix iglobal %d (%d != %d)\n", n, ival, iCheck);
	}
	if (i==10) return(-1);
	return(0);
}


/* For trajectories of unlimited length, PVT commands can be executed via sendReceiveCommand(),
 * but this has not been reliable enough, so if PVT_BY_CONTROLLER, we send the whole trajectory
 * to the controller via DGLOBAL variables.
 */


/**************************************************************************************/
static int loadTrajectory(SS_ID ssId, struct UserVar *pVar) {
	int i, j, n, status;
	char stringOut[100], reply[100];
	double position, p, v, t, dp, dtime;
	int iGlobalIndex;
	int intPosition;
	double accelDist, accelTime, decelDist, decelTime, positionLast;
	double home_position_set=0.;
	double posfbkprog, posfbkcal;

	pVar->loadingTrajectory = 1;

	sprintf(stringOut, "getparm(@0,%d)", 1);
	status = writeRead(ssId, pVar, stringOut, reply);
	encoder_runs_backwards = atoi(&reply[1]);
	if (pVar->debugLevel > 2) printf("loadTrajectory: encoder_runs_backwards=%d\n", encoder_runs_backwards);

	sprintf(stringOut, "getparm(@0,%d)", 166);
	status = writeRead(ssId, pVar, stringOut, reply);
	home_position_set = atof(&reply[1]);
	if (pVar->debugLevel > 2) printf("loadTrajectory: home_position_set=%f\n", home_position_set);

	status = writeIntAndCheck(ssId, pVar, 42, 50);

	/* There may be a position offset in place.  If so, scope data will need to be corrected. */
	/* This code doesn't seem to get at the difference between scope positions and commanded positions. */
	for (j=0; j<8; j++) {
		sprintf(stringOut, "pfbkprog(@%d)", j);
		status = writeRead(ssId, pVar, stringOut, reply);
		posfbkprog = atof(&reply[1]);
		sprintf(stringOut, "pfbkcal(@%d)", j);
		status = writeRead(ssId, pVar, stringOut, reply);
		posfbkcal = atof(&reply[1]);
		pVar->motorPosOffset[j] = posfbkprog - posfbkcal;
	}


	if (pVar->pulseMode != 3) {

		strcpy(stringOut, "PSOCONTROL @0 RESET");
		status = writeRead(ssId, pVar, stringOut, reply);
	}
#line 1327 "EnsembleTrajectoryScan.st"
	/* We can write an array of positions at which PSO pulses are wanted, and the array can be either
	 * the trajectory points, or points specified by the user in pulsePositions[].  If we're doing this,
	 * we'd like not to write the PSO positions unless they have changed.  If we're doing pulses at
	 * trajectory points, just write them every time, because we don't yet have a mechanism to keep track
	 * of everything that might require a rewrite.  But if we're doing pulses at pulsePositions[], make a
	 * note when we write them, and don't write them again unless pulsePositions[] has changed, or we've
	 * overwritten the IGLOBAL array with trajectory-point positions.
	 */ 
	if ((pVar->pulseMode == 1) || (pVar->pulseMode == 2)) {
		/* Program PSO array output */
		int np;
		int maxArrayPulses = ((8192) > (pVar->numGlobalIntegers - 50) ? (pVar->numGlobalIntegers - 50) : (8192));
		
		

		if ((pVar->pulseMode == 1) &&
			(pVar->pulsePositionsLoaded != 1)) {
			if (pVar->debugLevel > 2) printf("loadTrajectory: load PULSE_MODE_ARRAY array\n");
			j = 0; /* For now, we only support one motor */
			/* user has loaded an array of pulse positions into pulsePositions[] */
			positionLast = pVar->motorStart[j];
			iGlobalIndex = 50;
			if (pVar->numGlobalIntegers < (pVar->numPulsePositions + 50)) {
				printf("EnsembleTrajectoryScan: The Ensemble only has enough global integers for %d pulses\n",
					pVar->numGlobalIntegers - 50);
				pVar->numPulsePositions = pVar->numGlobalIntegers - 50;
			}
			if (pVar->numPulsePositions > 8192) {
				printf("EnsembleTrajectoryScan: The Ensemble can't load more than %d PSOARRAY pulses\n",
					8192);
				pVar->numPulsePositions = 8192;
			}
			for (i=0, np=0; i<pVar->numPulsePositions && np<maxArrayPulses; i++) {
				/* Add this pulse-out location to the list */
				np++;
				position = pVar->pulsePositions[i];
				intPosition = (int)(((position - positionLast)/pVar->epicsMotorMres[j])>0 ? ((position - positionLast)/pVar->epicsMotorMres[j])+0.5 : ((position - positionLast)/pVar->epicsMotorMres[j])-0.5);
				status = writeIntAndCheck(ssId, pVar, iGlobalIndex++, abs(intPosition));
				positionLast += intPosition*pVar->epicsMotorMres[j]; /* position of last pulse */
			}
			pVar->pulsePositionsLoaded = 1;
			pVar->numPulsePositionsLoaded = np;
		} else if ((pVar->pulseMode == 2) &&
				(pVar->pulsePositionsLoaded != 2)) {
			/* user wants pulses at trajectory points */
			if (pVar->debugLevel > 2) printf("loadTrajectory: load PULSE_MODE_TRAJPTS array\n");
			j = 0; /* For now, we only support one motor */
			positionLast = pVar->motorStart[j];
			iGlobalIndex = 50;
			if (pVar->numGlobalIntegers < (pVar->nelements + 50)) {
				printf("EnsembleTrajectoryScan: The Ensemble only has enough global integers for %d pulses\n",
					pVar->numGlobalIntegers - 50);
			}
			if (pVar->nelements > 8192) {
				printf("EnsembleTrajectoryScan: The Ensemble can't load more than %d PSOARRAY pulses\n",
					8192);
			}
			for (i=0, np=0; i<pVar->nelements && np<maxArrayPulses; i++) {
				/* enable pulses if we're within user specified range */
				if (i >= pVar->startPulses && i <= pVar->endPulses) {
					/* Add this pulse-out location to the list */
					np++;
					position = pVar->motorTrajectory[j][i];
					intPosition = (int)(((position - positionLast)/pVar->epicsMotorMres[j])>0 ? ((position - positionLast)/pVar->epicsMotorMres[j])+0.5 : ((position - positionLast)/pVar->epicsMotorMres[j])-0.5);
					status = writeIntAndCheck(ssId, pVar, iGlobalIndex++, abs(intPosition));
					positionLast += intPosition*pVar->epicsMotorMres[j]; /* position of last pulse */
				}
			}
			pVar->pulsePositionsLoaded = 2;
			pVar->numPulsePositionsLoaded = np;
		}

		/* Copy from IGLOBAL variables into the drive array */
		sprintf(stringOut, "PSOARRAY @0,%d,%d", 50, pVar->numPulsePositionsLoaded);
		status = writeRead(ssId, pVar, stringOut, reply);
		/* Send PSO pulses at specified positions. */
		strcpy(stringOut, "PSODISTANCE @0 ARRAY");
		status = writeRead(ssId, pVar, stringOut, reply);
	}
	/* digital I/O commands */
	/* For HLe controller, set parameter Axis:I/O:EncoderDivider to nonzero
	 * value to make the Aux I/O an output.
	 * Also, I set the Axis:I/O:IOSetup parameter to configure the Opto Output Mode
	 * for current sourcing.
	 */
	if (pVar->pulseMode != 3) {

		/* (total time, on time) in microseconds */
		sprintf(stringOut, "PSOPULSE @0 TIME %f,%f", pVar->pulseLenUS*1.5, pVar->pulseLenUS);
		status = writeRead(ssId, pVar, stringOut, reply);
		strcpy(stringOut, "PSOOUTPUT @0 PULSE");
		status = writeRead(ssId, pVar, stringOut, reply);

		/* some controllers need to track source 3 instead of 1. */
		/* strcpy(stringOut, "PSOTRACK @0 INPUT 1"); */
		sprintf(stringOut, "PSOTRACK @0 INPUT %d", pVar->pulseSrc);
		status = writeRead(ssId, pVar, stringOut, reply);

		/* encoder direction in which PSO pulses will be sent */
		sprintf(stringOut, "PSOTRACK @0 DIRECTION %d", pVar->pulseDir);
		status = writeRead(ssId, pVar, stringOut, reply);

		if ((pVar->pulseMode == 1) || (pVar->pulseMode == 2)) {
			/* Send PSO pulses at specified points. */
			strcpy(stringOut, "PSODISTANCE @0 ARRAY");
			status = writeRead(ssId, pVar, stringOut, reply);
		} else if (pVar->pulseMode == 0) {
			/* Just send fixed-distance pulses.  For now, don't even worry about StartPulses, EndPulses */
			dp = fabs(pVar->motorTrajectory[0][pVar->npoints-1] - pVar->motorTrajectory[0][0]) / pVar->npulses;
			sprintf(stringOut, "PSODISTANCE @0 FIXED %f UNITS", dp);
			status = writeRead(ssId, pVar, stringOut, reply);
		}
		strcpy(stringOut, "PSOCONTROL @0 ARM");
		status = writeRead(ssId, pVar, stringOut, reply);
	}


	/* trajectory commands */
	getMotorPositions(ssId, pVar, pVar->motorCurrent);

	strcpy(stringOut, "TASKSTATE(1)");
	status = writeRead(ssId, pVar, stringOut, reply);
	status = atoi(&reply[1]);
	if ((reply[0] == '!') || ((status != 1) && (status != 3) && (status != 5))) {
		strcpy(stringOut, "PROGRAM STOP 1");
		status = writeRead(ssId, pVar, stringOut, reply);
		strcpy(stringOut, "TASKSTATE(1)");
		status = writeRead(ssId, pVar, stringOut, reply);
	}

	status = writeIntAndCheck(ssId, pVar, 45, 0);
	strcpy(stringOut, "PROGRAM RUN 1, \"doCommand.bcx\"");
	status = writeRead(ssId, pVar, stringOut, reply);
	epicsThreadSleep(.1);


	/* Program SCOPE commands */
	pVar->nScopeDataPoints = pVar->npoints * 2.2;
	if (pVar->nScopeDataPoints > 8000) pVar->nScopeDataPoints = 8000;
	pVar->scopeDataIntervalMS = (int)((1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)>0 ? (1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)+0.5 : (1000 * (pVar->time*1.1)/pVar->nScopeDataPoints)-0.5);
	if (pVar->scopeDataIntervalMS < 1) pVar->scopeDataIntervalMS = 1;
	sprintf(stringOut, "SCOPEBUFFER %d", pVar->nScopeDataPoints);
	status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
	sprintf(stringOut, "SCOPETRIGPERIOD %d", pVar->scopeDataIntervalMS);
	status = sendReceiveCommand(ssId, pVar, stringOut, reply, 0);
#line 1473 "EnsembleTrajectoryScan.st"







#line 1481 "EnsembleTrajectoryScan.st"



	/* Get motor number into Ensemble's IGLOBAL(iarg1Var) for use by DOTRAJECTORY command. */
	for (j=0; j<8; j++) {
		if (pVar->moveAxis[j]) break;
	}
	status = writeIntAndCheck(ssId, pVar, 46, j);

	/* Calc accel portion of trajectory.  Note epicsMotorACCL is accel time. */
	accelTime = pVar->epicsMotorACCL[j];
	accelDist = (pVar->velocity[j][0] * pVar->epicsMotorACCL[j]) / 2;

	decelTime = pVar->epicsMotorACCL[j];
	decelDist = (pVar->velocity[j][pVar->npoints - 1] * pVar->epicsMotorACCL[j]) / 2;

	n = 0;
	status = 0;
	status += writeDoubleAndCheck(ssId, pVar, n++, pVar->motorTrajectory[j][0]);
	status += writeDoubleAndCheck(ssId, pVar, n++, pVar->velocity[j][0]);
	status += writeDoubleAndCheck(ssId, pVar, n++, accelTime);
	if (status) goto bad;

	for (i=1; i<pVar->npoints; i++) {
		p = pVar->motorTrajectory[j][i];
		v = pVar->velocity[j][i];
		t = accelTime + pVar->realTimeTrajectory[i];
		status += writeDoubleAndCheck(ssId, pVar, n++, p);
		status += writeDoubleAndCheck(ssId, pVar, n++, v);
		status += writeDoubleAndCheck(ssId, pVar, n++, t);
		if (status) goto bad;
	}

	/* add extra trajectory points to reduce end transient */
	p = 2*pVar->motorTrajectory[j][pVar->npoints-1] - pVar->motorTrajectory[j][pVar->npoints-2];
	v = pVar->velocity[j][pVar->npoints-1];
	t = accelTime + 2*pVar->realTimeTrajectory[pVar->npoints-1] - pVar->realTimeTrajectory[pVar->npoints-2];
	status += writeDoubleAndCheck(ssId, pVar, n++, p);
	status += writeDoubleAndCheck(ssId, pVar, n++, v);
	status += writeDoubleAndCheck(ssId, pVar, n++, t);
	if (status) goto bad;

	p = p + decelDist*.9;
	v = pVar->velocity[j][pVar->npoints-1]*.1;
	t = t + decelTime*.9;
	status += writeDoubleAndCheck(ssId, pVar, n++, p);
	status += writeDoubleAndCheck(ssId, pVar, n++, v);
	status += writeDoubleAndCheck(ssId, pVar, n++, t);
	if (status) goto bad;

	p = p + decelDist*.1;
	v = 0.;
	t = t + decelTime*.1;
	status += writeDoubleAndCheck(ssId, pVar, n++, p);
	status += writeDoubleAndCheck(ssId, pVar, n++, v);
	status += writeDoubleAndCheck(ssId, pVar, n++, t);
	if (status) goto bad;

	/* Set Ensemble's IGLOBAL(iarg2Var) to actual number of trajectory points, including accel/decel */
	status = writeIntAndCheck(ssId, pVar, 47, n/3);


	status = sendReceiveCommand(ssId, pVar, "SCOPETRIG", reply, 0);
#line 1545 "EnsembleTrajectoryScan.st"

	epicsTimeGetCurrent(&startTime);
	sprintf(stringOut, "DOTRAJECTORY");
	status = sendReceiveCommand(ssId, pVar, stringOut, reply, 0);











































































































































#line 1689 "EnsembleTrajectoryScan.st"

	if (pVar->abortState != 0) goto abort;
	
	strcpy(stringOut, "TASKSTATE(1)");
	status = writeRead(ssId, pVar, stringOut, reply);
	if (pVar->debugLevel) printf("TASKSTATE = '%s', ", reply);
	strcpy(stringOut, "TASKERROR(1)");
	status = writeRead(ssId, pVar, stringOut, reply);
	if (pVar->debugLevel) printf("TASKERROR = '%s', ", reply);
	for (i=0; i<50; i++) {
		strcpy(stringOut, "PLANESTATUS(0)");
		status = writeRead(ssId, pVar, stringOut, reply);
		if (reply[1] == '3') break;
		epicsThreadSleep(.1);
	}
	if (i>=50) {
		printf("loadTrajectory: trajectory didn't start. (PLANESTATUS = '%s')\n", reply);
		strcpy(stringOut, "VELOCITY OFF");
		status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
		/*strcpy(stringOut, "STARTABORT");*/
		/*status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);*/
		status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
		return(-2);
	}
	if (pVar->debugLevel) printf("PLANESTATUS = '%s'\n", reply);
	pVar->loadingTrajectory = 0;
	if (pVar->debugLevel) printf("loadTrajectory: normal exit after %.1f s wait\n", i/10.);
	return(0);

bad:
	printf("loadTrajectory: error\n");
	/* Find out why it failed. */
	strcpy(stringOut, "TASKSTATE(1)");
	status = writeRead(ssId, pVar, stringOut, reply);
	printf("TASKSTATE(1) returns '%s'\n", reply);
	strcpy(stringOut, "TASKERROR(1)");
	status = writeRead(ssId, pVar, stringOut, reply);
	printf("TASKERROR(1) returns '%s'\n", reply);
	strcpy(stringOut, "PLANESTATUS(0)");
	status = writeRead(ssId, pVar, stringOut, reply);
	printf("PLANESTATUS(0) returns '%s'\n", reply);
	strcpy(stringOut, "AXISSTATUS(@0)");
	status = writeRead(ssId, pVar, stringOut, reply);
	printf("AXISSTATUS(@0) returns '%s' (%x)\n", reply, atoi(&reply[1]));
	pVar->loadingTrajectory = 0;
	/* return(-1); */
	printf("loadTrajectory: aborting because of error\n");

abort:
	printf("loadTrajectory: aborted\n");
	strcpy(stringOut, "VELOCITY OFF");
	status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
	strcpy(stringOut, "STARTABORT");
	status = sendReceiveCommand(ssId, pVar, stringOut, reply, 1);
	status = writeRead(ssId, pVar, pVar->abortCommand, pVar->stringIn);
	pVar->abortState = 2;
	pVar->loadingTrajectory = 0;
	if (pVar->pulseMode != 3) {
		strcpy(stringOut, "PSOCONTROL @0 OFF");
		status = writeRead(ssId, pVar, stringOut, reply);
	}
	return(-1);
}

double eval_fStart(double fStart, double *motorReadbacks, double scopeDataInterval, int nScopeDataPoints,
	double *motorTrajectory, double *realTimeTrajectory, int npoints);
int  parabola(double *x, double *y, int npts, double *xFit);

static double trajEval(SS_ID ssId, struct UserVar *pVar, double *motorReadbacks, int scopeDataIntervalMS, int nScopeDataPoints,
	double *motorTrajectory, double *realTimeTrajectory, int npoints, double *motorError) {

	int i, rStart, lower, iThis;
	double fStart, fThis, frac, interp, scopeDataInterval = scopeDataIntervalMS*.001;
	double p;

	/* for optimizing fStart */
	double fTry, x[10], y[10];
	int nTry;

	/* fStart is the fractional index for which motorReadbacks[fStart] == motorTrajectory[0].  Find it. */
	lower = motorReadbacks[0] < motorTrajectory[0];
	for (rStart=0; rStart < nScopeDataPoints/2; rStart++) {
		if (pVar->debugLevel>5) printf("trajEval: motorReadbacks[rStart]=%f, motorTrajectory[0]=%f\n", motorReadbacks[rStart], motorTrajectory[0]);
		if ((motorReadbacks[rStart] > motorTrajectory[0]) == lower) break;
	}
	if (rStart>1 && fabs(motorReadbacks[rStart] - motorReadbacks[rStart-1]) > 1.e-3) {
		frac = (motorTrajectory[0] - motorReadbacks[rStart-1]) / (motorReadbacks[rStart] - motorReadbacks[rStart-1]);
	} else {
		frac = 0.;
	}
	fStart = 0.;
	frac = 0.;
	if (rStart>0) {
		fStart = (rStart-1) + frac;
	}
	if (pVar->debugLevel>5) printf("trajEval: rStart=%d, frac=%f, fStart=%f\n",  rStart, frac, fStart);

	/* Try to improve fStart */
	fTry = ((0) > (fStart-2) ? (0) : (fStart-2));
	nTry = 5;
	for (i=0; i<nTry; i++, fTry += 1) {
		x[i] = fTry;
		y[i] = eval_fStart(fTry, motorReadbacks, scopeDataInterval, nScopeDataPoints, motorTrajectory, realTimeTrajectory, npoints);
	}
	i = parabola(x, y, nTry, &fTry);
	if (i==0) fStart = fTry;
	if (pVar->debugLevel>5) printf("trajEval: fStart=%f\n", fStart);

	/* Calculate SUM(motorReadbacks[t+fStart] - motorTrajectory[t]) */
	for (i=0; i<npoints; i++) {
		fThis = fStart + (realTimeTrajectory[i] - realTimeTrajectory[0])/scopeDataInterval;
		iThis = floor(fThis);
		if (iThis+1 < nScopeDataPoints) {
			if (pVar->debugLevel>5) printf("trajEval: iThis=%d, motorReadbacks[iThis]=%f\n", iThis, motorReadbacks[iThis]);
			p = fThis-iThis;
			if ((iThis > 0) && (iThis+2 < nScopeDataPoints)) {
				/* Lagrange 4-point interpolation */
				interp = (-p*(p-1)*(p-2)/6)*motorReadbacks[iThis-1] +
						((p*p-1)*(p-2)/2)*motorReadbacks[iThis] +
						(-p*(p+1)*(p-2)/2)*motorReadbacks[iThis+1] +
						(p*(p*p-1)/6)*motorReadbacks[iThis+2];
			} else if ((iThis > 0) && (iThis+1 < nScopeDataPoints)) {
				/* Lagrange 3-point interpolation */
				interp = (p*(p-1)/2)*motorReadbacks[iThis-1] + (1-p*p)*motorReadbacks[iThis] + (p*(p+1)/2)*motorReadbacks[iThis+1];
			} else {
				/* linear interpolation */
				interp = motorReadbacks[iThis] + (motorReadbacks[iThis+1] - motorReadbacks[iThis])*p;
			}
			if (pVar->debugLevel>5) printf("trajEval: fThis=%f, interp=%f, motorTrajectory[%d]=%f, \n", fThis, interp, i, motorTrajectory[i]);
			motorReadbacks[i] = interp;
			motorError[i] = interp - motorTrajectory[i];
		} else {
			motorReadbacks[i] = 0;
			motorError[i] = 0;
		}
	}
	for(; i<nScopeDataPoints; i++) {
		motorReadbacks[i] = 0;
		motorError[i] = 0;
	}
	return(0.);
}

double eval_fStart(double fStart, double *motorReadbacks, double scopeDataInterval, int nScopeDataPoints,
	double *motorTrajectory, double *realTimeTrajectory, int npoints) {

	double fThis, p, interp, chisq = 0;
	int i, iThis, numChi = 0;

	/* Calculate SUM(motorReadbacks[t+fStart] - motorTrajectory[t]) */
	for (i=0; i<npoints; i++) {
		fThis = fStart + (realTimeTrajectory[i] - realTimeTrajectory[0])/scopeDataInterval;
		iThis = floor(fThis);
		if (iThis+1 < nScopeDataPoints) {
			/* printf("eval_fStart: iThis=%d, motorReadbacks[iThis]=%f\n", iThis, motorReadbacks[iThis]);*/
			p = fThis-iThis;
			if ((iThis > 0) && (iThis+2 < nScopeDataPoints)) {
				/* Lagrange 4-point interpolation */
				interp = (-p*(p-1)*(p-2)/6)*motorReadbacks[iThis-1] +
						((p*p-1)*(p-2)/2)*motorReadbacks[iThis] +
						(-p*(p+1)*(p-2)/2)*motorReadbacks[iThis+1] +
						(p*(p*p-1)/6)*motorReadbacks[iThis+2];
			} else if ((iThis > 0) && (iThis+1 < nScopeDataPoints)) {
				/* Lagrange 3-point interpolation */
				interp = (p*(p-1)/2)*motorReadbacks[iThis-1] + (1-p*p)*motorReadbacks[iThis] + (p*(p+1)/2)*motorReadbacks[iThis+1];
			} else {
				/* linear interpolation */
				interp = motorReadbacks[iThis] + (motorReadbacks[iThis+1] - motorReadbacks[iThis])*p;
			}
			/* printf("eval_fStart: fThis=%f, interp=%f, motorTrajectory[%d]=%f, \n", fThis, interp, i, motorTrajectory[i]);*/
			chisq += (interp - motorTrajectory[i]) * (interp - motorTrajectory[i]);
			numChi++;
		}
	}
	return(chisq/numChi);
}



int  parabola(double *x, double *y, int npts, double *xFit) {

	double xf, yf;
	double xx, yy, xi, xi2, xi3, xi4, yi, yixi, yixi2;
	int i;
	double numer, denom;
	double xmin=1e10, xmax=-1e10;

	/* make sums */
	xi = yi = yixi = xi2 = yixi2 = xi3 = xi4 = 0.0;
	for (i=0; i<npts; i++) {
		xmin = ((xmin) > (x[i]) ? (x[i]) : (xmin));
		xmax = ((xmax) > (x[i]) ? (xmax) : (x[i]));
		xi	  += (xx = x[i]);
		yi	  += (yy = y[i]);
		yixi  += yy * xx;
		xi2   += (xx *=x[i]);
		yixi2 += yy * xx;
		xi3   += (xx *= x[i]);
		xi4   += xx * x[i];
	}

	/* make averages */
	xi    /= npts;
	xi2   /= npts;
	xi3   /= npts;
	xi4   /= npts;
	yi    /= npts;
	yixi  /= npts;
	yixi2 /= npts;

	/* x coordinate of minimum of parabola */
	numer =    yi*(xi2*xi3 - xi*xi4) + yixi*(xi4 - xi2*xi2) + yixi2*(xi*xi2 - xi3);
	denom = 2*(yi*(xi2*xi2 - xi*xi3) + yixi*(xi3 -  xi*xi2) + yixi2*(xi*xi  - xi2));
	/* printf("	calculating xf: npts=%d; numer=%.3g; denom=%.3g\n", npts, numer, denom); */
	if (fabs(denom) < 1e-8) return(-1);
	xf = numer / denom;
	if ((xf < xmin) || (xf > xmax)) return(-1);	/* Don't extrapolate */

	numer = (xf*xf - 2*xf*xi + xi2) * (yixi2 - yi*xi2);
	denom = 2*xf*(xi*xi2 - xi3) - xi2*xi2 + xi4;
	yf = yi - numer/denom;
	if (fabs(denom) < 1e-8) return(-1);

	*xFit = xf;
	return(0);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void EnsembleTrajectoryScanRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&EnsembleTrajectoryScan);
}
epicsExportRegistrar(EnsembleTrajectoryScanRegistrar);
